"""
iCal Parser - Pure Functions for iCal Processing
Rich Hickey: "Parse data into immutable structures"
"""

import re
import requests
from typing import List, Dict, Any, Optional, Tuple
from datetime import datetime, timezone
import uuid
from urllib.parse import urlparse

from .schemas import EventData


def parse_ical_content(ical_content: str) -> Tuple[List[EventData], List[str]]:
    """
    Parse iCal content into structured event data
    Pure function - no side effects, deterministic output
    """
    events = []
    categories_set = set()
    
    # Split content into VEVENT blocks
    vevent_blocks = _extract_vevent_blocks(ical_content)
    
    for block in vevent_blocks:
        try:
            event = _parse_vevent_block(block)
            if event:
                events.append(event)
                categories_set.update(event.categories)
        except Exception as e:
            print(f"Warning: Failed to parse event block: {e}")
            continue
    
    return events, sorted(list(categories_set))


def fetch_ical_from_url(url: str, timeout: int = 30) -> Tuple[bool, Optional[str], Optional[str]]:
    """
    Fetch iCal content from URL
    Returns: (success, content, error_message)
    """
    try:
        # Validate URL
        parsed = urlparse(url)
        if not parsed.scheme or not parsed.netloc:
            return False, None, "Invalid URL format"
        
        # Make HTTP request
        response = requests.get(
            url, 
            timeout=timeout,
            headers={
                'User-Agent': 'iCal-Viewer/2.0 (+https://filter-ical.de)',
                'Accept': 'text/calendar, text/plain, */*'
            }
        )
        response.raise_for_status()
        
        # Validate content type
        content_type = response.headers.get('content-type', '').lower()
        if not any(ct in content_type for ct in ['text/calendar', 'text/plain', 'application/octet-stream']):
            print(f"Warning: Unexpected content type: {content_type}")
        
        return True, response.text, None
        
    except requests.exceptions.Timeout:
        return False, None, "Request timeout - calendar URL took too long to respond"
    except requests.exceptions.ConnectionError:
        return False, None, "Connection error - unable to reach calendar URL"
    except requests.exceptions.HTTPError as e:
        return False, None, f"HTTP error {e.response.status_code}: {e.response.reason}"
    except Exception as e:
        return False, None, f"Error fetching calendar: {str(e)}"


def generate_ical_content(events: List[EventData], calendar_name: str = "Filtered Calendar") -> str:
    """
    Generate RFC 5545 compliant iCal content from events
    Pure function - deterministic output
    """
    lines = [
        "BEGIN:VCALENDAR",
        "VERSION:2.0",
        "PRODID:-//iCal Viewer//Filter System//EN",
        "CALSCALE:GREGORIAN",
        "METHOD:PUBLISH",
        f"X-WR-CALNAME:{_escape_ical_text(calendar_name)}",
        f"X-WR-CALDESC:Filtered calendar generated by iCal Viewer",
        "X-WR-TIMEZONE:UTC"
    ]
    
    for event in events:
        lines.extend(_generate_vevent_lines(event))
    
    lines.append("END:VCALENDAR")
    
    return "\r\n".join(lines)


def extract_categories_from_events(events: List[EventData]) -> Dict[str, int]:
    """
    Extract category statistics from events
    Pure function - counts category occurrences
    """
    category_counts = {}
    
    for event in events:
        for category in event.categories:
            if category and category.strip():
                clean_category = category.strip()
                category_counts[clean_category] = category_counts.get(clean_category, 0) + 1
    
    return category_counts


def filter_events_by_categories(events: List[EventData], selected_categories: List[str], 
                               filter_mode: str = "include") -> List[EventData]:
    """
    Filter events by categories using include/exclude logic
    Pure function - returns new list
    """
    if not selected_categories:
        return events
    
    filtered_events = []
    
    for event in events:
        event_categories = [cat.strip().lower() for cat in event.categories if cat.strip()]
        selected_lower = [cat.strip().lower() for cat in selected_categories]
        
        has_selected_category = any(cat in event_categories for cat in selected_lower)
        
        if filter_mode == "include":
            if has_selected_category:
                filtered_events.append(event)
        else:  # exclude mode
            if not has_selected_category:
                filtered_events.append(event)
    
    return filtered_events


def filter_events_by_date_range(events: List[EventData], start_date: Optional[str] = None, 
                               end_date: Optional[str] = None) -> List[EventData]:
    """
    Filter events by date range
    Pure function - returns new list
    """
    if not start_date and not end_date:
        return events
    
    filtered_events = []
    
    for event in events:
        try:
            event_start = _parse_ical_datetime(event.dtstart)
            if not event_start:
                continue
            
            # Check start date
            if start_date:
                start_dt = datetime.fromisoformat(start_date.replace('Z', '+00:00'))
                if event_start < start_dt:
                    continue
            
            # Check end date
            if end_date:
                end_dt = datetime.fromisoformat(end_date.replace('Z', '+00:00'))
                if event_start > end_dt:
                    continue
            
            filtered_events.append(event)
            
        except Exception:
            continue
    
    return filtered_events


# === PRIVATE HELPER FUNCTIONS ===

def _extract_vevent_blocks(ical_content: str) -> List[str]:
    """Extract individual VEVENT blocks from iCal content"""
    blocks = []
    lines = ical_content.replace('\r\n', '\n').split('\n')
    
    current_block = []
    in_vevent = False
    
    for line in lines:
        line = line.strip()
        if line == "BEGIN:VEVENT":
            in_vevent = True
            current_block = [line]
        elif line == "END:VEVENT" and in_vevent:
            current_block.append(line)
            blocks.append('\n'.join(current_block))
            current_block = []
            in_vevent = False
        elif in_vevent:
            current_block.append(line)
    
    return blocks


def _parse_vevent_block(block: str) -> Optional[EventData]:
    """Parse a single VEVENT block into EventData"""
    lines = block.split('\n')
    properties = {}
    
    # Parse properties
    for line in lines:
        if ':' in line:
            prop_line = line.split(':', 1)
            prop_name = prop_line[0].split(';')[0]  # Remove parameters
            prop_value = prop_line[1] if len(prop_line) > 1 else ''
            properties[prop_name] = _unescape_ical_text(prop_value)
    
    # Extract required fields
    uid = properties.get('UID', f"generated-{uuid.uuid4()}")
    summary = properties.get('SUMMARY', 'No Title')
    dtstart = properties.get('DTSTART', '')
    
    if not dtstart:
        return None
    
    # Parse categories
    categories = []
    if 'CATEGORIES' in properties:
        categories = [cat.strip() for cat in properties['CATEGORIES'].split(',') if cat.strip()]
    
    # Extract additional fields
    description = properties.get('DESCRIPTION', '')
    location = properties.get('LOCATION', '')
    dtend = properties.get('DTEND', dtstart)
    
    return EventData(
        uid=uid,
        summary=summary,
        description=description,
        location=location,
        dtstart=dtstart,
        dtend=dtend,
        categories=categories
    )


def _parse_ical_datetime(dt_str: str) -> Optional[datetime]:
    """Parse iCal datetime string to Python datetime"""
    if not dt_str:
        return None
    
    try:
        # Remove TZID parameter if present
        if ';' in dt_str:
            dt_str = dt_str.split(':', 1)[1]
        
        # Handle different datetime formats
        if 'T' in dt_str:
            if dt_str.endswith('Z'):
                return datetime.fromisoformat(dt_str.replace('Z', '+00:00'))
            else:
                # Try to parse as local time
                return datetime.strptime(dt_str, '%Y%m%dT%H%M%S').replace(tzinfo=timezone.utc)
        else:
            # Date only
            return datetime.strptime(dt_str, '%Y%m%d').replace(tzinfo=timezone.utc)
    
    except Exception:
        return None


def _generate_vevent_lines(event: EventData) -> List[str]:
    """Generate VEVENT lines for a single event"""
    lines = [
        "BEGIN:VEVENT",
        f"UID:{event.uid}",
        f"SUMMARY:{_escape_ical_text(event.summary)}",
    ]
    
    if event.dtstart:
        lines.append(f"DTSTART:{event.dtstart}")
    
    if event.dtend and event.dtend != event.dtstart:
        lines.append(f"DTEND:{event.dtend}")
    
    if event.description:
        lines.append(f"DESCRIPTION:{_escape_ical_text(event.description)}")
    
    if event.location:
        lines.append(f"LOCATION:{_escape_ical_text(event.location)}")
    
    if event.categories:
        categories_str = ",".join(event.categories)
        lines.append(f"CATEGORIES:{_escape_ical_text(categories_str)}")
    
    lines.extend([
        "STATUS:CONFIRMED",
        "SEQUENCE:0",
        "END:VEVENT"
    ])
    
    return lines


def _escape_ical_text(text: str) -> str:
    """Escape text for iCal format"""
    if not text:
        return ""
    
    # Escape special characters
    text = text.replace('\\', '\\\\')
    text = text.replace(',', '\\,')
    text = text.replace(';', '\\;')
    text = text.replace('\n', '\\n')
    text = text.replace('\r', '\\r')
    
    return text


def _unescape_ical_text(text: str) -> str:
    """Unescape text from iCal format"""
    if not text:
        return ""
    
    # Unescape special characters
    text = text.replace('\\n', '\n')
    text = text.replace('\\r', '\r')
    text = text.replace('\\,', ',')
    text = text.replace('\\;', ';')
    text = text.replace('\\\\', '\\')
    
    return text