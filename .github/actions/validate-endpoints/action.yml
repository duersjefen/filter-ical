name: 'Validate Application Endpoints'
description: 'Parallel endpoint validation with comprehensive health checks'
author: 'Claude Code'

inputs:
  domain:
    description: 'Domain name to validate'
    required: true
  endpoints:
    description: 'Comma-separated list of endpoints to validate'
    required: true
    default: '/,/health,/api/calendars'
  timeout:
    description: 'Timeout per endpoint in seconds'
    required: false
    default: '10'
  retries:
    description: 'Number of retries per endpoint'
    required: false
    default: '3'

outputs:
  validation_status:
    description: 'Overall validation status (success|failed)'
  successful_endpoints:
    description: 'List of endpoints that passed validation'
  failed_endpoints:
    description: 'List of endpoints that failed validation'
  response_times:
    description: 'JSON object with response times for each endpoint'

runs:
  using: 'composite'
  steps:
    - name: üß™ Parse Endpoints
      shell: bash
      run: |
        # Convert comma-separated endpoints to array
        IFS=',' read -ra ENDPOINTS <<< "${{ inputs.endpoints }}"
        echo "endpoints_array=$(printf '%s\n' "${ENDPOINTS[@]}" | jq -R . | jq -s .)" >> $GITHUB_OUTPUT
      id: parse
      
    - name: üåê Validate Endpoints in Parallel
      shell: bash
      run: |
        domain="${{ inputs.domain }}"
        timeout_val="${{ inputs.timeout }}"
        retries="${{ inputs.retries }}"
        
        echo "üß™ Validating endpoints on https://$domain with ${retries} retries each..."
        
        # Create arrays for results
        successful_endpoints=()
        failed_endpoints=()
        declare -A response_times
        
        # Parse endpoints from JSON array
        endpoints=$(echo '${{ steps.parse.outputs.endpoints_array }}' | jq -r '.[]')
        
        # Function to validate single endpoint
        validate_endpoint() {
          local endpoint="$1"
          local url="https://$domain$endpoint"
          local attempt=1
          
          echo "üîç Testing: $url"
          
          while [ $attempt -le $retries ]; do
            # Use curl with timeout and measure response time
            response_time=$(curl -o /dev/null -s -w "%{time_total}" \
              --connect-timeout $timeout_val \
              --max-time $timeout_val \
              --fail \
              "$url" 2>/dev/null)
            
            curl_exit_code=$?
            
            if [ $curl_exit_code -eq 0 ]; then
              echo "‚úÖ $endpoint: SUCCESS (${response_time}s, attempt $attempt)"
              echo "$endpoint:success:$response_time" > "/tmp/result_$(echo $endpoint | tr '/' '_')"
              return 0
            else
              echo "‚ö†Ô∏è $endpoint: FAILED attempt $attempt/$retries (exit code: $curl_exit_code)"
              attempt=$((attempt + 1))
              [ $attempt -le $retries ] && sleep 2
            fi
          done
          
          echo "‚ùå $endpoint: FAILED after $retries attempts"
          echo "$endpoint:failed:0" > "/tmp/result_$(echo $endpoint | tr '/' '_')"
          return 1
        }
        
        # Launch parallel validation (using background processes)
        pids=()
        while IFS= read -r endpoint; do
          validate_endpoint "$endpoint" &
          pids+=($!)
        done <<< "$endpoints"
        
        # Wait for all validations to complete
        echo "‚è≥ Waiting for parallel validations to complete..."
        for pid in "${pids[@]}"; do
          wait $pid
        done
        
        # Collect results
        overall_success=true
        response_times_json="{"
        
        while IFS= read -r endpoint; do
          result_file="/tmp/result_$(echo $endpoint | tr '/' '_')"
          if [ -f "$result_file" ]; then
            result=$(cat "$result_file")
            IFS=':' read -r ep status time <<< "$result"
            
            if [ "$status" = "success" ]; then
              successful_endpoints+=("$endpoint")
              response_times_json="$response_times_json\"$endpoint\":$time,"
            else
              failed_endpoints+=("$endpoint")
              overall_success=false
              response_times_json="$response_times_json\"$endpoint\":null,"
            fi
            
            rm -f "$result_file"
          fi
        done <<< "$endpoints"
        
        # Clean up JSON (remove trailing comma)
        response_times_json="${response_times_json%,}}"
        
        # Output results
        if [ "$overall_success" = true ]; then
          echo "validation_status=success" >> $GITHUB_OUTPUT
          echo "‚úÖ All endpoints validated successfully"
        else
          echo "validation_status=failed" >> $GITHUB_OUTPUT
          echo "‚ùå Some endpoints failed validation"
        fi
        
        # Convert arrays to comma-separated strings
        successful_list=$(IFS=','; echo "${successful_endpoints[*]}")
        failed_list=$(IFS=','; echo "${failed_endpoints[*]}")
        
        echo "successful_endpoints=$successful_list" >> $GITHUB_OUTPUT
        echo "failed_endpoints=$failed_list" >> $GITHUB_OUTPUT
        echo "response_times=$response_times_json" >> $GITHUB_OUTPUT
        
        echo "üìä Validation Summary:"
        echo "   ‚úÖ Successful: $successful_list"
        echo "   ‚ùå Failed: $failed_list"
        echo "   ‚è±Ô∏è Response times: $response_times_json"
        
        # Exit with failure if any endpoint failed
        [ "$overall_success" = false ] && exit 1 || exit 0