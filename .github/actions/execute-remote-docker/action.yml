name: 'Execute Remote Docker Commands'
description: 'Atomic action: executes docker commands on remote host with native GitHub integration'
author: 'Claude Code'

inputs:
  containers:
    description: 'Space-separated list of containers to operate on'
    required: true
  operation:
    description: 'Operation to perform (deploy|clean-deploy|restart|health-check|rollback)'
    required: true
  nginx_restart:
    description: 'Whether to restart nginx (true/false)'
    required: false
    default: 'false'
  nginx_container:
    description: 'Nginx container name'
    required: false
    default: 'nginx'
  backup_tag:
    description: 'Backup tag to create/restore from'
    required: false
    default: ''

outputs:
  operation_status:
    description: 'Operation status (success|failed)'
  containers_affected:
    description: 'Containers that were actually affected'
  backup_created:
    description: 'Backup tag that was created'

runs:
  using: 'composite'
  steps:
    - name: ðŸ³ Execute Remote Docker Operation
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ env.EC2_HOST }}
        username: ${{ env.EC2_USER }}
        key: ${{ env.EC2_SSH_KEY }}
        debug: true
        script: |
          cd /opt/websites
          operation="${{ inputs.operation }}"
          requested_containers="${{ inputs.containers }}"
          ECR_REGISTRY="$ECR_REGISTRY"
          
          echo "ðŸ³ Executing operation: $operation on requested containers: $requested_containers"
          
          # Dynamic service name mapping from docker-compose.yml
          echo "ðŸ” Mapping requested container names to actual docker-compose services..."
          actual_containers=""
          
          for container in $requested_containers; do
            # Try to find the actual service name that matches the requested container
            if docker-compose config --services | grep -q "^${container}$"; then
              # Exact match found
              actual_service="$container"
              echo "   âœ… $container -> $actual_service (exact match)"
            elif docker-compose config --services | grep -q "^${container%-*}$"; then
              # Try without the last suffix (e.g., ical-viewer-backend -> ical-viewer)
              actual_service="${container%-*}"
              echo "   ðŸŽ¯ $container -> $actual_service (mapped)"
            elif docker-compose config --services | grep -q "^${container%%-*}$"; then
              # Try project name only (e.g., ical-viewer-backend -> ical-viewer from ical-viewer-backend)
              actual_service="${container%%-*}"
              echo "   ðŸŽ¯ $container -> $actual_service (project name)"
            else
              # Fallback: use original name and let docker-compose handle the error
              actual_service="$container"
              echo "   âš ï¸  $container -> $actual_service (fallback - may not exist)"
            fi
            
            actual_containers="$actual_containers $actual_service"
          done
          
          # Clean up extra spaces
          containers=$(echo $actual_containers | xargs)
          echo "ðŸ” Final mapped containers: $containers"
          
          case "$operation" in
            "deploy")
              # Create backup with timestamp
              backup_tag="backup-$(date +%s)"
              echo "ðŸ’¾ Creating backup: $backup_tag"
              
              for container in $containers; do
                current_image=$(docker-compose images "$container" 2>/dev/null | tail -n 1 | awk '{print $4":"$5}' || echo "")
                if [ -n "$current_image" ] && [ "$current_image" != ":" ]; then
                  docker tag "$current_image" "${current_image%:*}:$backup_tag" 2>/dev/null || true
                  echo "âœ… Backup created: $container -> $backup_tag"
                fi
              done
              
              # ECR Authentication refresh
              echo "ðŸ”‘ Refreshing ECR authentication..."
              aws ecr get-login-password --region eu-north-1 | docker login --username AWS --password-stdin 310829530903.dkr.ecr.eu-north-1.amazonaws.com
              
              # Zero-downtime deployment with proper error detection
              echo "ðŸš€ Executing zero-downtime deployment..."
              echo "ðŸ“¥ Pulling required images (MUST succeed)..."
              
              # Pull images based on environment
              if [ -n "$IMAGE_TAG" ]; then
                # Pull specific tagged images for staging/production
                echo "ðŸ·ï¸  Pulling specific tagged images: $IMAGE_TAG"
                for container in $containers; do
                  if ! docker pull "$ECR_REGISTRY/$container:$IMAGE_TAG"; then
                    echo "âŒ CRITICAL: Failed to pull $ECR_REGISTRY/$container:$IMAGE_TAG"
                    exit 1
                  fi
                  # Tag as latest locally for docker-compose compatibility
                  docker tag "$ECR_REGISTRY/$container:$IMAGE_TAG" "$ECR_REGISTRY/$container:latest"
                done
              else
                # Use docker-compose pull for standard deployment
                if ! docker-compose pull $containers; then
                  echo "âŒ CRITICAL: Docker pull failed! ECR authentication or network issue"
                  echo "ðŸ” Current images before failed pull:"
                  docker-compose images $containers || true
                  exit 1
                fi
              fi
              
              echo "âœ… Images pulled successfully, updating containers..."
              if ! docker-compose up -d --no-deps $containers; then
                echo "âŒ CRITICAL: Container startup failed!"
                docker-compose ps $containers || true
                exit 1
              fi
              
              # Verify containers are actually using new images
              echo "ðŸ” Verifying deployment actually updated containers..."
              sleep 5  # Give containers time to start
              for container in $containers; do
                # Get the image ID of the running container
                running_image=$(docker-compose ps -q "$container" | xargs docker inspect --format='{{.Image}}' 2>/dev/null || echo "")
                
                # Determine expected image tag based on environment
                if [ -n "$IMAGE_TAG" ]; then
                  # Use specific image tag (staging/production)
                  expected_tag="$IMAGE_TAG"
                else
                  # Fallback to latest for production
                  expected_tag="latest"
                fi
                
                # Get the image ID of the expected pulled image
                expected_image=$(docker images --format="{{.ID}}" "$ECR_REGISTRY/$container:$expected_tag" 2>/dev/null | head -1 || echo "")
                
                if [ -n "$running_image" ] && [ -n "$expected_image" ] && [ "$running_image" = "$expected_image" ]; then
                  echo "âœ… $container: Successfully updated to $expected_tag image"
                else
                  echo "âŒ CRITICAL: $container is NOT running the expected image!"
                  echo "   Running: $running_image"
                  echo "   Expected ($expected_tag): $expected_image"
                  exit 1
                fi
              done
              ;;
              
            "clean-deploy")
              # CLEAN DEPLOYMENT: Reset database and fresh startup
              echo "ðŸ§¹ CLEAN DEPLOYMENT: Resetting database and fresh startup!"
              echo "âš ï¸  This will destroy all data and start fresh"
              
              # Create backup before clean deployment
              backup_tag="backup-clean-$(date +%s)"
              echo "ðŸ’¾ Creating backup before clean deployment: $backup_tag"
              
              for container in $containers; do
                current_image=$(docker-compose images "$container" 2>/dev/null | tail -n 1 | awk '{print $4":"$5}' || echo "")
                if [ -n "$current_image" ] && [ "$current_image" != ":" ]; then
                  docker tag "$current_image" "${current_image%:*}:$backup_tag" 2>/dev/null || true
                  echo "âœ… Backup created: $container -> $backup_tag"
                fi
              done
              
              # Stop containers to ensure clean shutdown
              echo "ðŸ›‘ Stopping containers for clean reset..."
              docker-compose stop $containers
              
              # Remove containers to ensure fresh start
              echo "ðŸ—‘ï¸  Removing containers for fresh start..."
              docker-compose rm -f $containers
              
              # Remove database volumes to reset data
              echo "ðŸ—„ï¸  Removing database volumes for clean deployment..."
              docker volume ls -q | grep -E "(data|db|database|postgres|mysql|sqlite)" | xargs -r docker volume rm 2>/dev/null || true
              
              # ECR Authentication refresh
              echo "ðŸ”‘ Refreshing ECR authentication..."
              aws ecr get-login-password --region eu-north-1 | docker login --username AWS --password-stdin 310829530903.dkr.ecr.eu-north-1.amazonaws.com
              
              # Pull latest images with error detection
              echo "ðŸ“¥ Pulling latest container images (MUST succeed)..."
              if ! docker-compose pull $containers; then
                echo "âŒ CRITICAL: Docker pull failed during clean deployment!"
                echo "ðŸ” ECR authentication or network issue detected"
                exit 1
              fi
              
              # Start containers fresh (will trigger startup scripts)
              echo "ðŸš€ Starting containers with fresh database..."
              docker-compose up -d --no-deps $containers
              
              # Intelligent health monitoring with fallback for containers without health checks
              echo "ðŸ¥ Monitoring container health..."
              for i in {1..30}; do  # 2.5 minutes max for clean deployment
                unhealthy=0
                for container in $containers; do
                  # Extract the full status (columns 5 onwards contain the status)
                  container_status=$(docker-compose ps "$container" 2>/dev/null | grep "$container" | awk '{for(i=5;i<=NF;i++) printf "%s ", $i; print ""}' | sed 's/[[:space:]]*$//' || echo "")
                  if [[ "$container_status" =~ ^Up || "$container_status" =~ healthy ]]; then
                    echo "âœ… $container: $container_status"
                  else
                    echo "âš ï¸  $container: $container_status (waiting...)"
                    unhealthy=$((unhealthy + 1))
                  fi
                done
                
                if [ $unhealthy -eq 0 ]; then
                  echo "âœ… All containers running after $((i * 5))s"
                  break
                fi
                
                if [ $i -eq 30 ]; then
                  echo "âŒ Clean deployment timeout - some containers failed to start"
                  echo "ðŸ” Final container status:"
                  docker-compose ps $containers || echo "âŒ Failed to get container status"
                  exit 1
                fi
                
                sleep 5
              done
              
              # Conditional nginx restart
              if [ "${{ inputs.nginx_restart }}" = "true" ]; then
                echo "ðŸ”„ Restarting nginx..."
                docker-compose restart "${{ inputs.nginx_container }}"
                sleep 3
              fi
              
              echo "ðŸŽ‰ Clean deployment completed - fresh database initialized!"
              echo "backup_created=$backup_tag"
              ;;
              
            "health-check")
              echo "ðŸ¥ Checking container health..."
              healthy_count=0
              for container in $containers; do
                container_status=$(docker-compose ps "$container" 2>/dev/null | grep "$container" | awk '{print $3}' || echo "")
                if [[ "$container_status" == "Up" || "$container_status" =~ ^Up.*healthy ]]; then
                  echo "âœ… $container: $container_status"
                  healthy_count=$((healthy_count + 1))
                else
                  echo "âŒ $container: $container_status"
                fi
              done
              
              total_containers=$(echo $containers | wc -w)
              if [ $healthy_count -eq $total_containers ]; then
                echo "âœ… All $total_containers containers are running"
              else
                echo "âŒ Only $healthy_count/$total_containers containers are running"
                docker-compose ps $containers || echo "âŒ Failed to get container status"
                exit 1
              fi
              ;;
              
            "rollback")
              backup_tag="${{ inputs.backup_tag }}"
              if [ -z "$backup_tag" ]; then
                echo "âŒ No backup tag provided for rollback"
                exit 1
              fi
              
              echo "ðŸ”„ Rolling back to: $backup_tag"
              for container in $containers; do
                # Find the backup image
                backup_image=$(docker images --format "{{.Repository}}:{{.Tag}}" | grep ":$backup_tag" | head -1)
                if [ -n "$backup_image" ]; then
                  # Tag it as latest
                  repo_name="${backup_image%:*}"
                  docker tag "$backup_image" "$repo_name:latest"
                  echo "âœ… Restored $container from $backup_tag"
                else
                  echo "âŒ No backup found for $container with tag $backup_tag"
                fi
              done
              
              # Restart containers with restored images
              docker-compose up -d --no-deps $containers
              ;;
              
            *)
              echo "âŒ Unknown operation: $operation"
              exit 1
              ;;
          esac
      env:
        EC2_HOST: ${{ env.EC2_HOST }}
        EC2_USER: ${{ env.EC2_USER }}
        EC2_SSH_KEY: ${{ env.EC2_SSH_KEY }}
        ECR_REGISTRY: ${{ env.ECR_REGISTRY }}
        IMAGE_TAG: ${{ env.IMAGE_TAG }}
    
    - name: Handle Operation Success  
      if: success()
      shell: bash
      run: |
        echo "operation_status=success" >> $GITHUB_OUTPUT
        echo "containers_affected=${{ inputs.containers }}" >> $GITHUB_OUTPUT
        echo "backup_created=backup-$(date +%s)" >> $GITHUB_OUTPUT
    
    - name: Handle Operation Failure
      if: failure()
      shell: bash
      run: |
        echo "operation_status=failed" >> $GITHUB_OUTPUT
        echo "containers_affected=" >> $GITHUB_OUTPUT
        echo "backup_created=" >> $GITHUB_OUTPUT