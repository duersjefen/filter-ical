name: 'Execute Remote Docker Commands'
description: 'Atomic action: executes docker commands on remote host with native GitHub integration'
author: 'Claude Code'

inputs:
  containers:
    description: 'Space-separated list of containers to operate on'
    required: true
  operation:
    description: 'Operation to perform (deploy|clean-deploy|restart|health-check|rollback)'
    required: true
  nginx_restart:
    description: 'Whether to restart nginx (true/false)'
    required: false
    default: 'false'
  nginx_container:
    description: 'Nginx container name'
    required: false
    default: 'nginx'
  backup_tag:
    description: 'Backup tag to create/restore from'
    required: false
    default: ''

outputs:
  operation_status:
    description: 'Operation status (success|failed)'
  containers_affected:
    description: 'Containers that were actually affected'
  backup_created:
    description: 'Backup tag that was created'

runs:
  using: 'composite'
  steps:
    - name: ðŸ³ Execute Remote Docker Operation
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ env.EC2_HOST }}
        username: ${{ env.EC2_USER }}
        key: ${{ env.EC2_SSH_KEY }}
        debug: true
        envs: AWS_ACCOUNT_ID,AWS_REGION,ECR_REGISTRY,IMAGE_TAG,BRANCH_NAME
        script: |
          cd /opt/websites
          
          # CRITICAL: Export required environment variables for docker-compose
          export AWS_ACCOUNT_ID="${AWS_ACCOUNT_ID:-310829530903}"
          export AWS_REGION="${AWS_REGION:-eu-north-1}"
          export ECR_REGISTRY="${ECR_REGISTRY}"
          
          echo "ðŸ” Environment validation:"
          echo "   AWS_ACCOUNT_ID: $AWS_ACCOUNT_ID"
          echo "   AWS_REGION: $AWS_REGION"
          echo "   ECR_REGISTRY: $ECR_REGISTRY"
          
          # Validate required variables
          if [ -z "$AWS_ACCOUNT_ID" ] || [ -z "$AWS_REGION" ] || [ -z "$ECR_REGISTRY" ]; then
            echo "âŒ CRITICAL: Missing required environment variables"
            echo "   AWS_ACCOUNT_ID: ${AWS_ACCOUNT_ID:-MISSING}"
            echo "   AWS_REGION: ${AWS_REGION:-MISSING}"
            echo "   ECR_REGISTRY: ${ECR_REGISTRY:-MISSING}"
            exit 1
          fi
          
          # Ensure docker-compose.yml exists (rename from docker-compose.production.yml if needed)
          if [ -f "docker-compose.production.yml" ] && [ ! -f "docker-compose.yml" ]; then
            echo "ðŸ”„ Using docker-compose.production.yml as docker-compose.yml"
            cp docker-compose.production.yml docker-compose.yml
          fi
          
          # Validate docker-compose file can be parsed with environment variables
          echo "ðŸ” Validating docker-compose configuration..."
          if ! docker-compose config >/dev/null 2>&1; then
            echo "âŒ CRITICAL: docker-compose.yml configuration is invalid"
            echo "ðŸ” Attempting to show docker-compose config errors:"
            docker-compose config || true
            exit 1
          fi
          
          operation="${{ inputs.operation }}"
          requested_containers="${{ inputs.containers }}"
          
          echo "ðŸ³ Executing operation: $operation on requested containers: $requested_containers"
          
          # List available services for debugging
          echo "ðŸ” Available docker-compose services:"
          docker-compose config --services | sed 's/^/   /'
          
          # Simple and reliable container validation
          echo "ðŸ” Validating requested containers exist in docker-compose..."
          containers=""
          invalid_containers=""
          
          for container in $requested_containers; do
            if docker-compose config --services | grep -q "^${container}$"; then
              containers="$containers $container"
              echo "   âœ… $container (valid service)"
            else
              invalid_containers="$invalid_containers $container"
              echo "   âŒ $container (invalid service)"
            fi
          done
          
          # Exit if any invalid containers found
          if [ -n "$invalid_containers" ]; then
            echo "âŒ CRITICAL: Invalid container names detected:$invalid_containers"
            echo "ðŸ” Available services:"
            docker-compose config --services | sed 's/^/   /'
            exit 1
          fi
          
          # Clean up extra spaces
          containers=$(echo $containers | xargs)
          echo "ðŸ” Valid containers to operate on: $containers"
          
          case "$operation" in
            "deploy")
              # Create backup with timestamp
              backup_tag="backup-$(date +%s)"
              echo "ðŸ’¾ Creating backup: $backup_tag"
              backup_count=0
              
              for container in $containers; do
                # Get the currently running image for this container
                current_image=""
                
                # Try multiple methods to get the current image
                container_id=$(docker-compose ps -q "$container" 2>/dev/null || echo "")
                if [ -n "$container_id" ]; then
                  current_image=$(docker inspect --format='{{.Config.Image}}' "$container_id" 2>/dev/null || echo "")
                fi
                
                # Fallback: get from docker-compose images
                if [ -z "$current_image" ] || [ "$current_image" = ":" ]; then
                  current_image=$(docker-compose images "$container" 2>/dev/null | tail -n 1 | awk '{print $4":"$5}' || echo "")
                fi
                
                if [ -n "$current_image" ] && [ "$current_image" != ":" ] && [ "$current_image" != "<none>:<none>" ]; then
                  # Create backup tag
                  repo_name="${current_image%:*}"
                  if docker tag "$current_image" "$repo_name:$backup_tag" 2>/dev/null; then
                    echo "âœ… Backup created: $container -> $current_image -> $backup_tag"
                    backup_count=$((backup_count + 1))
                  else
                    echo "âš ï¸  Failed to create backup for $container ($current_image)"
                  fi
                else
                  echo "âš ï¸  No current image found for $container, skipping backup"
                fi
              done
              
              echo "ðŸ’¾ Backup summary: $backup_count/$( echo $containers | wc -w) containers backed up with tag: $backup_tag"
              
              # ECR Authentication refresh with validation
              echo "ðŸ”‘ Refreshing ECR authentication..."
              echo "   ECR Registry: $ECR_REGISTRY"
              echo "   AWS Region: $AWS_REGION"
              
              # Test AWS credentials first
              if ! aws sts get-caller-identity >/dev/null 2>&1; then
                echo "âŒ CRITICAL: AWS credentials not available or invalid"
                echo "ðŸ” AWS CLI version: $(aws --version 2>&1 || echo 'AWS CLI not found')"
                exit 1
              fi
              
              # Get ECR login with proper error handling
              echo "ðŸ” Getting ECR login token..."
              if ! aws ecr get-login-password --region "$AWS_REGION" | docker login --username AWS --password-stdin "$ECR_REGISTRY"; then
                echo "âŒ CRITICAL: ECR authentication failed"
                echo "ðŸ” Testing basic AWS access..."
                aws sts get-caller-identity || true
                echo "ðŸ” Testing ECR access..."
                aws ecr describe-repositories --region "$AWS_REGION" --max-items 1 || true
                exit 1
              fi
              
              echo "âœ… ECR authentication successful"
              
              # Zero-downtime deployment with proper error detection
              echo "ðŸš€ Executing zero-downtime deployment..."
              echo "ðŸ“¥ Pulling required images (MUST succeed)..."
              
              # Pull images based on environment with validation
              if [ -n "$IMAGE_TAG" ]; then
                # Pull specific tagged images for staging/production
                echo "ðŸ·ï¸  Pulling specific tagged images: $IMAGE_TAG"
                
                # First, verify all images exist in ECR
                echo "ðŸ” Verifying images exist in ECR before pulling..."
                for container in $containers; do
                  image_uri="$ECR_REGISTRY/$container:$IMAGE_TAG"
                  echo "   Checking: $image_uri"
                  if ! aws ecr describe-images --region "$AWS_REGION" --repository-name "$container" --image-ids imageTag="$IMAGE_TAG" >/dev/null 2>&1; then
                    echo "âŒ CRITICAL: Image does not exist in ECR: $image_uri"
                    echo "ðŸ” Available tags for $container:"
                    aws ecr describe-images --region "$AWS_REGION" --repository-name "$container" --query 'imageDetails[*].imageTags[0]' --output text 2>/dev/null | head -10 || echo "   Could not list tags"
                    exit 1
                  fi
                  echo "   âœ… $image_uri exists in ECR"
                done
                
                # Now pull the verified images
                echo "ðŸ“¥ Pulling verified images..."
                for container in $containers; do
                  image_uri="$ECR_REGISTRY/$container:$IMAGE_TAG"
                  echo "   Pulling: $image_uri"
                  if ! docker pull "$image_uri"; then
                    echo "âŒ CRITICAL: Failed to pull $image_uri"
                    exit 1
                  fi
                  # Tag as latest locally for docker-compose compatibility
                  docker tag "$image_uri" "$ECR_REGISTRY/$container:latest"
                  echo "   âœ… $container: pulled and tagged as latest"
                done
              else
                # Use docker-compose pull for standard deployment (fallback to latest tags)
                echo "ðŸ“¥ Pulling images using docker-compose (latest tags)..."
                if ! docker-compose pull $containers; then
                  echo "âŒ CRITICAL: Docker pull failed! ECR authentication or network issue"
                  echo "ðŸ” Current images before failed pull:"
                  docker-compose images $containers || true
                  exit 1
                fi
              fi
              
              echo "âœ… Images pulled successfully, updating containers..."
              if ! docker-compose up -d --no-deps $containers; then
                echo "âŒ CRITICAL: Container startup failed!"
                docker-compose ps $containers || true
                exit 1
              fi
              
              # Comprehensive deployment verification
              echo "ðŸ” Verifying deployment success..."
              sleep 5  # Give containers time to start
              
              deployment_success=0
              total_containers=$(echo $containers | wc -w)
              
              for container in $containers; do
                echo "ðŸ” Checking $container..."
                
                # Check if container is running
                container_status=$(docker-compose ps "$container" 2>/dev/null | grep "$container" | awk '{for(i=5;i<=NF;i++) printf "%s ", $i; print ""}' | sed 's/[[:space:]]*$//' || echo "")
                
                if ! echo "$container_status" | grep -q "Up"; then
                  echo "âŒ $container: Container is not running (Status: $container_status)"
                  echo "ðŸ” Container logs (last 20 lines):"
                  docker-compose logs --tail=20 "$container" 2>/dev/null | sed 's/^/   /' || echo "   Could not retrieve logs"
                  continue
                fi
                
                # Check image consistency
                running_image=$(docker-compose ps -q "$container" | xargs docker inspect --format='{{.Image}}' 2>/dev/null || echo "")
                
                # Determine expected image tag
                if [ -n "$IMAGE_TAG" ]; then
                  expected_tag="$IMAGE_TAG"
                else
                  expected_tag="latest"
                fi
                
                expected_image=$(docker images --format="{{.ID}}" "$ECR_REGISTRY/$container:$expected_tag" 2>/dev/null | head -1 || echo "")
                
                if [ -n "$running_image" ] && [ -n "$expected_image" ] && [ "$running_image" = "$expected_image" ]; then
                  echo "âœ… $container: Running correct image ($expected_tag)"
                  
                  # Test container health if health check is available
                  if echo "$container_status" | grep -q "healthy"; then
                    echo "âœ… $container: Health check passing"
                  elif echo "$container_status" | grep -q "unhealthy"; then
                    echo "âš ï¸  $container: Health check failing but container is running"
                  else
                    echo "â„¹ï¸  $container: No health check configured"
                  fi
                  
                  deployment_success=$((deployment_success + 1))
                else
                  echo "âŒ $container: Image mismatch"
                  echo "   Running: $running_image"
                  echo "   Expected ($expected_tag): $expected_image"
                  echo "ðŸ” Available images for $container:"
                  docker images | grep "$container" | sed 's/^/   /' || echo "   No images found"
                fi
              done
              
              # Final deployment validation
              echo ""
              echo "ðŸ“Š Deployment Summary:"
              echo "   Successfully deployed: $deployment_success/$total_containers containers"
              
              if [ $deployment_success -eq $total_containers ]; then
                echo "âœ… Deployment completed successfully!"
                
                # Optional nginx restart
                if [ "${{ inputs.nginx_restart }}" = "true" ]; then
                  echo "ðŸ”„ Restarting nginx as requested..."
                  docker-compose restart "${{ inputs.nginx_container }}"
                  sleep 3
                  echo "âœ… Nginx restarted"
                fi
              else
                echo "âŒ CRITICAL: Deployment failed - $((total_containers - deployment_success)) containers not properly deployed"
                echo "ðŸ” Current container status:"
                docker-compose ps $containers || echo "   Could not get container status"
                exit 1
              fi
              ;;
              
            "clean-deploy")
              # CLEAN DEPLOYMENT: Reset database and fresh startup
              echo "ðŸ§¹ CLEAN DEPLOYMENT: Resetting database and fresh startup!"
              echo "âš ï¸  This will destroy all data and start fresh"
              
              # Create backup before clean deployment
              backup_tag="backup-clean-$(date +%s)"
              echo "ðŸ’¾ Creating backup before clean deployment: $backup_tag"
              
              for container in $containers; do
                current_image=$(docker-compose images "$container" 2>/dev/null | tail -n 1 | awk '{print $4":"$5}' || echo "")
                if [ -n "$current_image" ] && [ "$current_image" != ":" ]; then
                  docker tag "$current_image" "${current_image%:*}:$backup_tag" 2>/dev/null || true
                  echo "âœ… Backup created: $container -> $backup_tag"
                fi
              done
              
              # Stop containers to ensure clean shutdown
              echo "ðŸ›‘ Stopping containers for clean reset..."
              docker-compose stop $containers
              
              # Remove containers to ensure fresh start
              echo "ðŸ—‘ï¸  Removing containers for fresh start..."
              docker-compose rm -f $containers
              
              # Remove database volumes to reset data
              echo "ðŸ—„ï¸  Removing database volumes for clean deployment..."
              docker volume ls -q | grep -E "(data|db|database|postgres|mysql|sqlite)" | xargs -r docker volume rm 2>/dev/null || true
              
              # ECR Authentication refresh (clean-deploy)
              echo "ðŸ”‘ Refreshing ECR authentication for clean deployment..."
              if ! aws ecr get-login-password --region "$AWS_REGION" | docker login --username AWS --password-stdin "$ECR_REGISTRY"; then
                echo "âŒ CRITICAL: ECR authentication failed during clean deployment"
                exit 1
              fi
              echo "âœ… ECR authentication successful for clean deployment"
              
              # Pull latest images with error detection
              echo "ðŸ“¥ Pulling latest container images (MUST succeed)..."
              if ! docker-compose pull $containers; then
                echo "âŒ CRITICAL: Docker pull failed during clean deployment!"
                echo "ðŸ” ECR authentication or network issue detected"
                exit 1
              fi
              
              # Start containers fresh (will trigger startup scripts)
              echo "ðŸš€ Starting containers with fresh database..."
              docker-compose up -d --no-deps $containers
              
              # Intelligent health monitoring with fallback for containers without health checks
              echo "ðŸ¥ Monitoring container health..."
              for i in {1..30}; do  # 2.5 minutes max for clean deployment
                unhealthy=0
                for container in $containers; do
                  # Extract the full status (columns 5 onwards contain the status)
                  container_status=$(docker-compose ps "$container" 2>/dev/null | grep "$container" | awk '{for(i=5;i<=NF;i++) printf "%s ", $i; print ""}' | sed 's/[[:space:]]*$//' || echo "")
                  if [[ "$container_status" =~ ^Up || "$container_status" =~ healthy ]]; then
                    echo "âœ… $container: $container_status"
                  else
                    echo "âš ï¸  $container: $container_status (waiting...)"
                    unhealthy=$((unhealthy + 1))
                  fi
                done
                
                if [ $unhealthy -eq 0 ]; then
                  echo "âœ… All containers running after $((i * 5))s"
                  break
                fi
                
                if [ $i -eq 30 ]; then
                  echo "âŒ Clean deployment timeout - some containers failed to start"
                  echo "ðŸ” Final container status:"
                  docker-compose ps $containers || echo "âŒ Failed to get container status"
                  exit 1
                fi
                
                sleep 5
              done
              
              # Conditional nginx restart
              if [ "${{ inputs.nginx_restart }}" = "true" ]; then
                echo "ðŸ”„ Restarting nginx..."
                docker-compose restart "${{ inputs.nginx_container }}"
                sleep 3
              fi
              
              echo "ðŸŽ‰ Clean deployment completed - fresh database initialized!"
              echo "backup_created=$backup_tag"
              ;;
              
            "health-check")
              echo "ðŸ¥ Checking container health..."
              healthy_count=0
              for container in $containers; do
                container_status=$(docker-compose ps "$container" 2>/dev/null | grep "$container" | awk '{print $3}' || echo "")
                if [[ "$container_status" == "Up" || "$container_status" =~ ^Up.*healthy ]]; then
                  echo "âœ… $container: $container_status"
                  healthy_count=$((healthy_count + 1))
                else
                  echo "âŒ $container: $container_status"
                fi
              done
              
              total_containers=$(echo $containers | wc -w)
              if [ $healthy_count -eq $total_containers ]; then
                echo "âœ… All $total_containers containers are running"
              else
                echo "âŒ Only $healthy_count/$total_containers containers are running"
                docker-compose ps $containers || echo "âŒ Failed to get container status"
                exit 1
              fi
              ;;
              
            "rollback")
              backup_tag="${{ inputs.backup_tag }}"
              
              # Auto-discover the most recent backup if none provided
              if [ -z "$backup_tag" ]; then
                echo "ðŸ” No specific backup tag provided, finding most recent backup..."
                # Find the most recent backup tag across all containers
                backup_tag=$(docker images --format "{{.Tag}}" | grep "^backup-" | sort -nr | head -1)
                if [ -n "$backup_tag" ]; then
                  echo "âœ… Found recent backup: $backup_tag"
                else
                  echo "âŒ No backup images found! Cannot perform rollback"
                  echo "ðŸ” Available images:"
                  docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.CreatedAt}}" | grep -E "(backup-|latest)" || echo "   No backup or latest images found"
                  exit 1
                fi
              fi
              
              echo "ðŸ”„ Rolling back to: $backup_tag"
              rollback_success=0
              
              for container in $containers; do
                # Find backup images for this container
                backup_images=$(docker images --format "{{.Repository}}:{{.Tag}}" | grep ":$backup_tag" | grep "$container")
                
                if [ -n "$backup_images" ]; then
                  # Use the first matching backup image
                  backup_image=$(echo "$backup_images" | head -1)
                  repo_name="${backup_image%:*}"
                  
                  echo "ðŸ”„ Rolling back $container using $backup_image"
                  docker tag "$backup_image" "$repo_name:latest"
                  echo "âœ… Restored $container from $backup_tag"
                  rollback_success=$((rollback_success + 1))
                else
                  echo "âš ï¸  No backup found for $container with tag $backup_tag"
                  # Try to use the most recent image for this container
                  recent_image=$(docker images --format "{{.Repository}}:{{.Tag}}" | grep "$container" | grep -v ":$backup_tag" | head -1)
                  if [ -n "$recent_image" ]; then
                    repo_name="${recent_image%:*}"
                    docker tag "$recent_image" "$repo_name:latest"
                    echo "âš ï¸  Using recent image as fallback: $recent_image"
                    rollback_success=$((rollback_success + 1))
                  fi
                fi
              done
              
              if [ $rollback_success -eq 0 ]; then
                echo "âŒ CRITICAL: No containers could be rolled back"
                exit 1
              fi
              
              echo "ðŸš€ Restarting containers with restored images..."
              docker-compose up -d --no-deps $containers
              
              echo "âœ… Rollback completed: $rollback_success/$( echo $containers | wc -w) containers restored"
              ;;
              
            *)
              echo "âŒ Unknown operation: $operation"
              exit 1
              ;;
          esac
      env:
        EC2_HOST: ${{ env.EC2_HOST }}
        EC2_USER: ${{ env.EC2_USER }}
        EC2_SSH_KEY: ${{ env.EC2_SSH_KEY }}
        ECR_REGISTRY: ${{ env.ECR_REGISTRY }}
        IMAGE_TAG: ${{ env.IMAGE_TAG }}
    
    - name: Handle Operation Success  
      if: success()
      shell: bash
      run: |
        echo "operation_status=success" >> $GITHUB_OUTPUT
        echo "containers_affected=${{ inputs.containers }}" >> $GITHUB_OUTPUT
        echo "backup_created=backup-$(date +%s)" >> $GITHUB_OUTPUT
    
    - name: Handle Operation Failure
      if: failure()
      shell: bash
      run: |
        echo "operation_status=failed" >> $GITHUB_OUTPUT
        echo "containers_affected=" >> $GITHUB_OUTPUT
        echo "backup_created=" >> $GITHUB_OUTPUT