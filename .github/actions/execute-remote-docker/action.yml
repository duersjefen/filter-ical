name: 'Execute Remote Docker Commands'
description: 'Atomic action: executes docker commands on remote host with native GitHub integration'
author: 'Claude Code'

inputs:
  containers:
    description: 'Space-separated list of containers to operate on'
    required: true
  operation:
    description: 'Operation to perform (deploy|clean-deploy|restart|health-check|rollback)'
    required: true
  nginx_restart:
    description: 'Whether to restart nginx (true/false)'
    required: false
    default: 'false'
  nginx_container:
    description: 'Nginx container name'
    required: false
    default: 'nginx'
  backup_tag:
    description: 'Backup tag to create/restore from'
    required: false
    default: ''

outputs:
  operation_status:
    description: 'Operation status (success|failed)'
  containers_affected:
    description: 'Containers that were actually affected'
  backup_created:
    description: 'Backup tag that was created'

runs:
  using: 'composite'
  steps:
    - name: üê≥ Execute Remote Docker Operation
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ env.EC2_HOST }}
        username: ${{ env.EC2_USER }}
        key: ${{ env.EC2_SSH_KEY }}
        debug: true
        envs: AWS_ACCOUNT_ID,AWS_REGION,ECR_REGISTRY,IMAGE_TAG,BRANCH_NAME
        script: |
          cd /opt/websites
          
          # CRITICAL: Export required environment variables for docker-compose
          export AWS_ACCOUNT_ID="${AWS_ACCOUNT_ID:-310829530903}"
          export AWS_REGION="${AWS_REGION:-eu-north-1}"
          export ECR_REGISTRY="${ECR_REGISTRY}"
          
          echo "üîç Environment validation:"
          echo "   AWS_ACCOUNT_ID: $AWS_ACCOUNT_ID"
          echo "   AWS_REGION: $AWS_REGION"
          echo "   ECR_REGISTRY: $ECR_REGISTRY"
          
          # Validate required variables
          if [ -z "$AWS_ACCOUNT_ID" ] || [ -z "$AWS_REGION" ] || [ -z "$ECR_REGISTRY" ]; then
            echo "‚ùå CRITICAL: Missing required environment variables"
            echo "   AWS_ACCOUNT_ID: ${AWS_ACCOUNT_ID:-MISSING}"
            echo "   AWS_REGION: ${AWS_REGION:-MISSING}"
            echo "   ECR_REGISTRY: ${ECR_REGISTRY:-MISSING}"
            exit 1
          fi
          
          # Ensure docker-compose.yml exists (rename from docker-compose.production.yml if needed)
          if [ -f "docker-compose.production.yml" ] && [ ! -f "docker-compose.yml" ]; then
            echo "üîÑ Using docker-compose.production.yml as docker-compose.yml"
            cp docker-compose.production.yml docker-compose.yml
          fi
          
          # Validate docker-compose file can be parsed with environment variables
          echo "üîç Validating docker-compose configuration..."
          if ! docker-compose config >/dev/null 2>&1; then
            echo "‚ùå CRITICAL: docker-compose.yml configuration is invalid"
            echo "üîç Attempting to show docker-compose config errors:"
            docker-compose config || true
            exit 1
          fi
          
          operation="${{ inputs.operation }}"
          requested_containers="${{ inputs.containers }}"
          
          echo "üê≥ Executing operation: $operation on requested containers: $requested_containers"
          
          # List available services for debugging
          echo "üîç Available docker-compose services:"
          docker-compose config --services | sed 's/^/   /'
          
          # Simple and reliable container validation
          echo "üîç Validating requested containers exist in docker-compose..."
          containers=""
          invalid_containers=""
          
          for container in $requested_containers; do
            if docker-compose config --services | grep -q "^${container}$"; then
              containers="$containers $container"
              echo "   ‚úÖ $container (valid service)"
            else
              invalid_containers="$invalid_containers $container"
              echo "   ‚ùå $container (invalid service)"
            fi
          done
          
          # Exit if any invalid containers found
          if [ -n "$invalid_containers" ]; then
            echo "‚ùå CRITICAL: Invalid container names detected:$invalid_containers"
            echo "üîç Available services:"
            docker-compose config --services | sed 's/^/   /'
            exit 1
          fi
          
          # Clean up extra spaces
          containers=$(echo $containers | xargs)
          echo "üîç Valid containers to operate on: $containers"
          
          case "$operation" in
            "deploy")
              # Create backup with timestamp
              backup_tag="backup-$(date +%s)"
              echo "üíæ Creating backup: $backup_tag"
              backup_count=0
              
              for container in $containers; do
                # Get the currently running image for this container
                current_image=""
                
                # Try multiple methods to get the current image
                container_id=$(docker-compose ps -q "$container" 2>/dev/null || echo "")
                if [ -n "$container_id" ]; then
                  current_image=$(docker inspect --format='{{.Config.Image}}' "$container_id" 2>/dev/null || echo "")
                fi
                
                # Fallback: get from docker-compose images
                if [ -z "$current_image" ] || [ "$current_image" = ":" ]; then
                  current_image=$(docker-compose images "$container" 2>/dev/null | tail -n 1 | awk '{print $4":"$5}' || echo "")
                fi
                
                if [ -n "$current_image" ] && [ "$current_image" != ":" ] && [ "$current_image" != "<none>:<none>" ]; then
                  # Create backup tag
                  repo_name="${current_image%:*}"
                  if docker tag "$current_image" "$repo_name:$backup_tag" 2>/dev/null; then
                    echo "‚úÖ Backup created: $container -> $current_image -> $backup_tag"
                    backup_count=$((backup_count + 1))
                  else
                    echo "‚ö†Ô∏è  Failed to create backup for $container ($current_image)"
                  fi
                else
                  echo "‚ö†Ô∏è  No current image found for $container, skipping backup"
                fi
              done
              
              echo "üíæ Backup summary: $backup_count/$( echo $containers | wc -w) containers backed up with tag: $backup_tag"
              
              # ECR Authentication refresh with validation
              echo "üîë Refreshing ECR authentication..."
              echo "   ECR Registry: $ECR_REGISTRY"
              echo "   AWS Region: $AWS_REGION"
              
              # Test AWS credentials first
              if ! aws sts get-caller-identity >/dev/null 2>&1; then
                echo "‚ùå CRITICAL: AWS credentials not available or invalid"
                echo "üîç AWS CLI version: $(aws --version 2>&1 || echo 'AWS CLI not found')"
                exit 1
              fi
              
              # Get ECR login with proper error handling
              echo "üîê Getting ECR login token..."
              if ! aws ecr get-login-password --region "$AWS_REGION" | docker login --username AWS --password-stdin "$ECR_REGISTRY"; then
                echo "‚ùå CRITICAL: ECR authentication failed"
                echo "üîç Testing basic AWS access..."
                aws sts get-caller-identity || true
                echo "üîç Testing ECR access..."
                aws ecr describe-repositories --region "$AWS_REGION" --max-items 1 || true
                exit 1
              fi
              
              echo "‚úÖ ECR authentication successful"
              
              # Zero-downtime deployment with proper error detection
              echo "üöÄ Executing zero-downtime deployment..."
              echo "üì• Pulling required images (MUST succeed)..."
              
              # Pull images based on environment with validation
              if [ -n "$IMAGE_TAG" ]; then
                # Pull specific tagged images for staging/production
                echo "üè∑Ô∏è  Pulling specific tagged images: $IMAGE_TAG"
                
                # First, verify all images exist in ECR
                echo "üîç Verifying images exist in ECR before pulling..."
                for container in $containers; do
                  image_uri="$ECR_REGISTRY/$container:$IMAGE_TAG"
                  echo "   Checking: $image_uri"
                  if ! aws ecr describe-images --region "$AWS_REGION" --repository-name "$container" --image-ids imageTag="$IMAGE_TAG" >/dev/null 2>&1; then
                    echo "‚ùå CRITICAL: Image does not exist in ECR: $image_uri"
                    echo "üîç Available tags for $container:"
                    aws ecr describe-images --region "$AWS_REGION" --repository-name "$container" --query 'imageDetails[*].imageTags[0]' --output text 2>/dev/null | head -10 || echo "   Could not list tags"
                    exit 1
                  fi
                  echo "   ‚úÖ $image_uri exists in ECR"
                done
                
                # Now pull the verified images
                echo "üì• Pulling verified images..."
                for container in $containers; do
                  image_uri="$ECR_REGISTRY/$container:$IMAGE_TAG"
                  echo "   Pulling: $image_uri"
                  if ! docker pull "$image_uri"; then
                    echo "‚ùå CRITICAL: Failed to pull $image_uri"
                    exit 1
                  fi
                  # Tag as latest locally for docker-compose compatibility
                  docker tag "$image_uri" "$ECR_REGISTRY/$container:latest"
                  echo "   ‚úÖ $container: pulled and tagged as latest"
                done
              else
                # Use docker-compose pull for standard deployment (fallback to latest tags)
                echo "üì• Pulling images using docker-compose (latest tags)..."
                if ! docker-compose pull $containers; then
                  echo "‚ùå CRITICAL: Docker pull failed! ECR authentication or network issue"
                  echo "üîç Current images before failed pull:"
                  docker-compose images $containers || true
                  exit 1
                fi
              fi
              
              echo "‚úÖ Images pulled successfully, updating containers..."
              if ! docker-compose up -d --no-deps $containers; then
                echo "‚ùå CRITICAL: Container startup failed!"
                docker-compose ps $containers || true
                exit 1
              fi
              
              # Comprehensive deployment verification
              echo "üîç Verifying deployment success..."
              sleep 5  # Give containers time to start
              
              deployment_success=0
              total_containers=$(echo $containers | wc -w)
              
              for container in $containers; do
                echo "üîç Checking $container..."
                
                # Check if container is running
                container_status=$(docker-compose ps "$container" 2>/dev/null | grep "$container" | awk '{for(i=5;i<=NF;i++) printf "%s ", $i; print ""}' | sed 's/[[:space:]]*$//' || echo "")
                
                if ! echo "$container_status" | grep -q "Up"; then
                  echo "‚ùå $container: Container is not running (Status: $container_status)"
                  echo "üîç Container logs (last 20 lines):"
                  docker-compose logs --tail=20 "$container" 2>/dev/null | sed 's/^/   /' || echo "   Could not retrieve logs"
                  continue
                fi
                
                # Check image consistency
                running_image=$(docker-compose ps -q "$container" | xargs docker inspect --format='{{.Image}}' 2>/dev/null || echo "")
                
                # Determine expected image tag
                if [ -n "$IMAGE_TAG" ]; then
                  expected_tag="$IMAGE_TAG"
                else
                  expected_tag="latest"
                fi
                
                expected_image=$(docker images --format="{{.ID}}" "$ECR_REGISTRY/$container:$expected_tag" 2>/dev/null | head -1 || echo "")
                
                if [ -n "$running_image" ] && [ -n "$expected_image" ] && [ "$running_image" = "$expected_image" ]; then
                  echo "‚úÖ $container: Running correct image ($expected_tag)"
                  
                  # Test container health if health check is available
                  if echo "$container_status" | grep -q "healthy"; then
                    echo "‚úÖ $container: Health check passing"
                  elif echo "$container_status" | grep -q "unhealthy"; then
                    echo "‚ö†Ô∏è  $container: Health check failing but container is running"
                  else
                    echo "‚ÑπÔ∏è  $container: No health check configured"
                  fi
                  
                  deployment_success=$((deployment_success + 1))
                else
                  echo "‚ùå $container: Image mismatch"
                  echo "   Running: $running_image"
                  echo "   Expected ($expected_tag): $expected_image"
                  echo "üîç Available images for $container:"
                  docker images | grep "$container" | sed 's/^/   /' || echo "   No images found"
                fi
              done
              
              # Final deployment validation
              echo ""
              echo "üìä Deployment Summary:"
              echo "   Successfully deployed: $deployment_success/$total_containers containers"
              
              if [ $deployment_success -eq $total_containers ]; then
                echo "‚úÖ Deployment completed successfully!"
                
                # Optional nginx restart
                if [ "${{ inputs.nginx_restart }}" = "true" ]; then
                  echo "üîÑ Restarting nginx as requested..."
                  docker-compose restart "${{ inputs.nginx_container }}"
                  sleep 3
                  echo "‚úÖ Nginx restarted"
                fi
              else
                echo "‚ùå CRITICAL: Deployment failed - $((total_containers - deployment_success)) containers not properly deployed"
                echo "üîç Current container status:"
                docker-compose ps $containers || echo "   Could not get container status"
                exit 1
              fi
              ;;
              
            "clean-deploy")
              # CLEAN DEPLOYMENT: Reset database and fresh startup
              echo "üßπ CLEAN DEPLOYMENT: Resetting database and fresh startup!"
              echo "‚ö†Ô∏è  This will destroy all data and start fresh"
              
              # Create backup before clean deployment
              backup_tag="backup-clean-$(date +%s)"
              echo "üíæ Creating backup before clean deployment: $backup_tag"
              
              for container in $containers; do
                current_image=$(docker-compose images "$container" 2>/dev/null | tail -n 1 | awk '{print $4":"$5}' || echo "")
                if [ -n "$current_image" ] && [ "$current_image" != ":" ]; then
                  docker tag "$current_image" "${current_image%:*}:$backup_tag" 2>/dev/null || true
                  echo "‚úÖ Backup created: $container -> $backup_tag"
                fi
              done
              
              # Stop containers to ensure clean shutdown
              echo "üõë Stopping containers for clean reset..."
              docker-compose stop $containers
              
              # Remove containers to ensure fresh start
              echo "üóëÔ∏è  Removing containers for fresh start..."
              docker-compose rm -f $containers
              
              # Remove database volumes to reset data
              echo "üóÑÔ∏è  Removing database volumes for clean deployment..."
              docker volume ls -q | grep -E "(data|db|database|postgres|mysql|sqlite)" | xargs -r docker volume rm 2>/dev/null || true
              
              # ECR Authentication refresh (clean-deploy)
              echo "üîë Refreshing ECR authentication for clean deployment..."
              if ! aws ecr get-login-password --region "$AWS_REGION" | docker login --username AWS --password-stdin "$ECR_REGISTRY"; then
                echo "‚ùå CRITICAL: ECR authentication failed during clean deployment"
                exit 1
              fi
              echo "‚úÖ ECR authentication successful for clean deployment"
              
              # Pull latest images with error detection
              echo "üì• Pulling latest container images (MUST succeed)..."
              if ! docker-compose pull $containers; then
                echo "‚ùå CRITICAL: Docker pull failed during clean deployment!"
                echo "üîç ECR authentication or network issue detected"
                exit 1
              fi
              
              # Start containers fresh (will trigger startup scripts)
              echo "üöÄ Starting containers with fresh database..."
              docker-compose up -d --no-deps $containers
              
              # Intelligent health monitoring with fallback for containers without health checks
              echo "üè• Monitoring container health..."
              for i in {1..30}; do  # 2.5 minutes max for clean deployment
                unhealthy=0
                for container in $containers; do
                  # Extract the full status (columns 5 onwards contain the status)
                  container_status=$(docker-compose ps "$container" 2>/dev/null | grep "$container" | awk '{for(i=5;i<=NF;i++) printf "%s ", $i; print ""}' | sed 's/[[:space:]]*$//' || echo "")
                  if [[ "$container_status" =~ ^Up || "$container_status" =~ healthy ]]; then
                    echo "‚úÖ $container: $container_status"
                  else
                    echo "‚ö†Ô∏è  $container: $container_status (waiting...)"
                    unhealthy=$((unhealthy + 1))
                  fi
                done
                
                if [ $unhealthy -eq 0 ]; then
                  echo "‚úÖ All containers running after $((i * 5))s"
                  break
                fi
                
                if [ $i -eq 30 ]; then
                  echo "‚ùå Clean deployment timeout - some containers failed to start"
                  echo "üîç Final container status:"
                  docker-compose ps $containers || echo "‚ùå Failed to get container status"
                  exit 1
                fi
                
                sleep 5
              done
              
              # Conditional nginx restart
              if [ "${{ inputs.nginx_restart }}" = "true" ]; then
                echo "üîÑ Restarting nginx..."
                docker-compose restart "${{ inputs.nginx_container }}"
                sleep 3
              fi
              
              echo "üéâ Clean deployment completed - fresh database initialized!"
              echo "backup_created=$backup_tag"
              ;;
              
            "health-check")
              echo "üè• Checking container health..."
              healthy_count=0
              for container in $containers; do
                container_status=$(docker-compose ps "$container" 2>/dev/null | grep "$container" | awk '{print $3}' || echo "")
                if [[ "$container_status" == "Up" || "$container_status" =~ ^Up.*healthy ]]; then
                  echo "‚úÖ $container: $container_status"
                  healthy_count=$((healthy_count + 1))
                else
                  echo "‚ùå $container: $container_status"
                fi
              done
              
              total_containers=$(echo $containers | wc -w)
              if [ $healthy_count -eq $total_containers ]; then
                echo "‚úÖ All $total_containers containers are running"
              else
                echo "‚ùå Only $healthy_count/$total_containers containers are running"
                docker-compose ps $containers || echo "‚ùå Failed to get container status"
                exit 1
              fi
              ;;
              
            "rollback")
              backup_tag="${{ inputs.backup_tag }}"
              
              # Auto-discover the most recent backup if none provided
              if [ -z "$backup_tag" ]; then
                echo "üîç No specific backup tag provided, finding most recent backup..."
                # Find the most recent backup tag across all containers
                backup_tag=$(docker images --format "{{.Tag}}" | grep "^backup-" | sort -nr | head -1)
                if [ -n "$backup_tag" ]; then
                  echo "‚úÖ Found recent backup: $backup_tag"
                else
                  echo "‚ùå No backup images found! Cannot perform rollback"
                  echo "üîç Available images:"
                  docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.CreatedAt}}" | grep -E "(backup-|latest)" || echo "   No backup or latest images found"
                  exit 1
                fi
              fi
              
              echo "üîÑ Rolling back to: $backup_tag"
              rollback_success=0
              
              for container in $containers; do
                # Find backup images for this container
                backup_images=$(docker images --format "{{.Repository}}:{{.Tag}}" | grep ":$backup_tag" | grep "$container")
                
                if [ -n "$backup_images" ]; then
                  # Use the first matching backup image
                  backup_image=$(echo "$backup_images" | head -1)
                  repo_name="${backup_image%:*}"
                  
                  echo "üîÑ Rolling back $container using $backup_image"
                  docker tag "$backup_image" "$repo_name:latest"
                  echo "‚úÖ Restored $container from $backup_tag"
                  rollback_success=$((rollback_success + 1))
                else
                  echo "‚ö†Ô∏è  No backup found for $container with tag $backup_tag"
                  # Try to use the most recent image for this container
                  recent_image=$(docker images --format "{{.Repository}}:{{.Tag}}" | grep "$container" | grep -v ":$backup_tag" | head -1)
                  if [ -n "$recent_image" ]; then
                    repo_name="${recent_image%:*}"
                    docker tag "$recent_image" "$repo_name:latest"
                    echo "‚ö†Ô∏è  Using recent image as fallback: $recent_image"
                    rollback_success=$((rollback_success + 1))
                  fi
                fi
              done
              
              if [ $rollback_success -eq 0 ]; then
                echo "‚ùå CRITICAL: No containers could be rolled back"
                exit 1
              fi
              
              echo "üöÄ Restarting containers with restored images..."
              docker-compose up -d --no-deps $containers
              
              echo "‚úÖ Rollback completed: $rollback_success/$( echo $containers | wc -w) containers restored"
              ;;
              
            *)
              echo "‚ùå Unknown operation: $operation"
              exit 1
              ;;
          esac
      env:
        EC2_HOST: ${{ env.EC2_HOST }}
        EC2_USER: ${{ env.EC2_USER }}
        EC2_SSH_KEY: ${{ env.EC2_SSH_KEY }}
        ECR_REGISTRY: ${{ env.ECR_REGISTRY }}
        IMAGE_TAG: ${{ env.IMAGE_TAG }}
    
    - name: Handle Operation Success  
      if: success()
      shell: bash
      run: |
        echo "operation_status=success" >> $GITHUB_OUTPUT
        echo "containers_affected=${{ inputs.containers }}" >> $GITHUB_OUTPUT
        echo "backup_created=backup-$(date +%s)" >> $GITHUB_OUTPUT
    
    - name: Handle Operation Failure
      if: failure()
      shell: bash
      run: |
        echo "operation_status=failed" >> $GITHUB_OUTPUT
        echo "containers_affected=" >> $GITHUB_OUTPUT
        echo "backup_created=" >> $GITHUB_OUTPUT