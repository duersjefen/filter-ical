# =============================================================================
# iCal Viewer - Production Deployment Pipeline (Python + Vue 3)
# =============================================================================
# 
# This workflow provides robust, zero-downtime deployment of the iCal Viewer
# application to AWS infrastructure. It features:
#
# - Intelligent change detection to optimize deployment speed
# - Comprehensive health validation with fail-fast error handling  
# - Zero-downtime rolling updates
# - Extensive logging and debugging information
# - Multiple fallback strategies for reliability
#
# Architecture:
#   Domain: https://filter-ical.de
#   Infrastructure: AWS EC2 + ECR + Let's Encrypt SSL
#   Containers: nginx (reverse proxy) + backend (Python/FastAPI) + frontend (Vue 3/Vite)
#
# Security: Uses OIDC for AWS authentication (no hardcoded credentials)
# =============================================================================

name: Deploy Multi-App Infrastructure to AWS

on:
  push:
    branches: [main, master]  # Deploy on push to main branches
  pull_request:
    branches: [main, master]  # Test on PRs (deploy job only runs on main)
  workflow_dispatch:          # Allow manual triggering

# Environment configuration for consistent deployment
env:
  AWS_REGION: eu-north-1
  ECR_REGISTRY: 310829530903.dkr.ecr.eu-north-1.amazonaws.com
  ECR_REPOSITORY_BACKEND: ical-viewer-backend
  ECR_REPOSITORY_FRONTEND: ical-viewer-frontend
  DOMAIN_NAME: filter-ical.de
  DEPLOYMENT_TIMEOUT: 300  # 5 minutes max for deployments

permissions:
  id-token: write   # Required for requesting the JWT
  contents: read    # Required for actions/checkout

jobs:
  # ===========================================================================
  # TEST PHASE
  # ===========================================================================
  # Validates code quality before deployment. This job must pass for 
  # deployment to proceed.
  
  test:
    name: üß™ Run Tests
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    steps:
    - name: üì• Checkout code
      uses: actions/checkout@v4
    
    - name: üß™ Execute all tests (Language Independent)
      run: |
        echo "üöÄ Running language-independent test suite..."
        
        # Use universal make targets that work with any language
        make ci-test

  # ===========================================================================
  # BUILD AND DEPLOYMENT PHASE
  # ===========================================================================
  # Only runs on main branch pushes after tests pass. Performs intelligent
  # builds and zero-downtime deployment with comprehensive validation.
  
  build-and-deploy:
    name: üöÄ Build & Deploy to Production
    needs: test
    runs-on: ubuntu-latest
    timeout-minutes: 30
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    
    steps:
    - name: üìä Initialize deployment performance tracking
      run: |
        echo "DEPLOY_START_TIME=$(date +%s)" >> $GITHUB_ENV
        echo "üöÄ Deployment started at: $(date)"
        echo "üìä Performance tracking initialized"
    
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Configure AWS credentials using OIDC
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: arn:aws:iam::310829530903:role/GitHubActionsRole
        role-session-name: GitHubActionsSession
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Detect changed components
      id: changes
      run: |
        # =============================================================================
        # INTELLIGENT CHANGE DETECTION WITH ROBUST FALLBACKS
        # =============================================================================
        # This step determines which components need updating to optimize deployment
        # and avoid unnecessary container rebuilds. It uses multiple fallback 
        # strategies to handle different Git scenarios reliably.
        
        echo "üîç Analyzing repository changes for targeted deployment..."
        
        # Function to detect changes with multiple fallback strategies
        detect_component_changes() {
          local component="$1"
          local pattern="$2"
          local output_var="${component}_changed"
          
          echo "üìÅ Checking for $component changes (pattern: $pattern)..."
          
          # Strategy 1: Compare with previous commit (ideal case)
          if git diff --name-only HEAD~1 HEAD 2>/dev/null | grep -E "$pattern" >/dev/null 2>&1; then
            echo "$output_var=true" >> $GITHUB_OUTPUT
            echo "‚úÖ $component changes detected (HEAD~1 comparison)"
            return 0
          fi
          
          # Strategy 2: Compare with origin/master (for PRs and shallow clones)
          if git diff --name-only origin/master HEAD 2>/dev/null | grep -E "$pattern" >/dev/null 2>&1; then
            echo "$output_var=true" >> $GITHUB_OUTPUT
            echo "‚úÖ $component changes detected (origin/master comparison)"
            return 0
          fi
          
          # Strategy 3: Check current commit only (fallback for single commits)
          if git show --name-only HEAD | grep -E "$pattern" >/dev/null 2>&1; then
            echo "$output_var=true" >> $GITHUB_OUTPUT
            echo "‚úÖ $component changes detected (HEAD commit analysis)"
            return 0
          fi
          
          # Strategy 4: FAIL-SAFE - Force update if detection uncertain
          echo "$output_var=true" >> $GITHUB_OUTPUT
          echo "‚ö†Ô∏è  $component change detection uncertain - FORCING update for safety"
          echo "   This ensures deployment reliability over optimization"
          return 0
        }
        
        # Detect frontend changes (includes nginx config that affects frontend routing)
        detect_component_changes "frontend" "^frontend/|^infrastructure/production-nginx.conf"
        
        # Detect backend changes
        detect_component_changes "backend" "^backend/"
        
        # Summary of detection results
        echo ""
        echo "üìã Change Detection Summary:"
        echo "   Frontend: $([ "$(grep -o 'frontend_changed=true' <<<"$(cat $GITHUB_OUTPUT)")" ] && echo 'UPDATE REQUIRED' || echo 'No changes')"
        echo "   Backend:  $([ "$(grep -o 'backend_changed=true' <<<"$(cat $GITHUB_OUTPUT)")" ] && echo 'UPDATE REQUIRED' || echo 'No changes')"
        echo ""
    
    # ===========================================================================
    # PARALLEL BUILD OPTIMIZATION
    # ===========================================================================
    # Build frontend application and Docker containers concurrently for maximum speed
    
    - name: üèóÔ∏è Build applications (Language Independent)
      if: steps.changes.outputs.frontend_changed == 'true' || steps.changes.outputs.backend_changed == 'true'
      run: |
        echo "üöÄ Building applications using language-independent interface..."
        
        # Use universal make targets that work with any language
        make ci-build
    
    - name: üê≥üåç Build and push containers (parallel)
      if: steps.changes.outputs.backend_changed == 'true' || steps.changes.outputs.frontend_changed == 'true'
      env:
        IMAGE_TAG: ${{ github.sha }}
      run: |
        echo "üöÄ Starting parallel container builds for maximum speed..."
        
        # Function to build backend container
        build_backend() {
          if [ "${{ steps.changes.outputs.backend_changed }}" == "true" ]; then
            echo "üì¶ Building backend container with advanced caching..."
            cd backend
            
            # Validate Docker environment and dependencies before build
            echo "üîç Pre-build validation checks..."
            if ! docker --version >/dev/null 2>&1; then
              echo "‚ùå Docker not available in CI environment"
              return 1
            fi
            
            if ! docker buildx version >/dev/null 2>&1; then
              echo "‚ùå Docker Buildx not available in CI environment"  
              return 1
            fi
            
            # Verify essential files exist
            if [ ! -f "Dockerfile" ]; then
              echo "‚ùå Backend Dockerfile missing - cannot build container"
              return 1
            fi
            
            if [ ! -f "requirements.txt" ]; then
              echo "‚ùå Backend requirements.txt missing - cannot build container"
              return 1
            fi
            
            if [ ! -d "app" ]; then
              echo "‚ùå Backend app directory missing - cannot build container"
              return 1
            fi
            
            echo "‚úÖ All pre-build validations passed"
            
            echo "‚öôÔ∏è  Backend container build configuration:"
            echo "   Registry: $ECR_REGISTRY"
            echo "   Repository: $ECR_REPOSITORY_BACKEND"
            echo "   Tags: $IMAGE_TAG, latest"
            echo "   Platform: linux/amd64"
            echo "   Cache: GitHub Actions (GHA)"
            
            # Build with comprehensive error handling
            echo "üèóÔ∏è  Starting robust backend container build..."
            
            if docker buildx build \
              --target production \
              --cache-from type=gha,scope=backend \
              --cache-to type=gha,scope=backend,mode=max \
              --platform linux/amd64 \
              --build-arg BUILDKIT_INLINE_CACHE=1 \
              --label "version=$IMAGE_TAG" \
              --label "build-date=$(date -u '+%Y-%m-%dT%H:%M:%SZ')" \
              --label "commit=$GITHUB_SHA" \
              --label "ci-system=github-actions" \
              --label "build-type=production" \
              -t $ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:$IMAGE_TAG \
              -t $ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:latest \
              --push .; then
              echo "‚úÖ Backend container built and pushed successfully"
              echo "üìä Container details: $ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:$IMAGE_TAG"
              return 0
            else
              echo "‚ùå Backend container build failed"
              echo "üîç Build failure troubleshooting:"
              echo "   ‚Ä¢ Check Dockerfile syntax and Python requirements"
              echo "   ‚Ä¢ Verify requirements.txt format and dependencies"
              echo "   ‚Ä¢ Check ECR repository permissions and network connectivity"
              echo "   ‚Ä¢ Review Docker build logs above for specific errors"
              return 1
            fi
          else
            echo "‚è≠Ô∏è  Backend unchanged, skipping container build"
            return 0
          fi
        }
        
        # Function to build frontend container
        build_frontend() {
          if [ "${{ steps.changes.outputs.frontend_changed }}" == "true" ]; then
            echo "üé® Building frontend container with nginx configuration..."
            cd frontend
            
            # Docker build handles all frontend build steps - no need for local build
            echo "üì¶ Docker will handle all frontend build steps and dependencies"
            
            echo "‚öôÔ∏è  Frontend container build configuration:"
            echo "   Registry: $ECR_REGISTRY"
            echo "   Repository: $ECR_REPOSITORY_FRONTEND"
            echo "   Tags: $IMAGE_TAG, latest"
            echo "   Platform: linux/amd64"
            echo "   Cache: GitHub Actions (GHA)"
            
            # Validate Docker environment and dependencies before build
            echo "üîç Pre-build validation checks..."
            if ! docker --version >/dev/null 2>&1; then
              echo "‚ùå Docker not available in CI environment"
              return 1
            fi
            
            if ! docker buildx version >/dev/null 2>&1; then
              echo "‚ùå Docker Buildx not available in CI environment"  
              return 1
            fi
            
            # Verify essential files exist
            if [ ! -f "Dockerfile" ]; then
              echo "‚ùå Frontend Dockerfile missing - cannot build container"
              return 1
            fi
            
            if [ ! -f "package.json" ]; then
              echo "‚ùå Frontend package.json missing - cannot build container"
              return 1
            fi
            
            if [ ! -f "package-lock.json" ]; then
              echo "‚ùå Frontend package-lock.json missing - regenerate with 'npm install'"
              return 1
            fi
            
            echo "‚úÖ All pre-build validations passed"
            
            # Build with comprehensive error handling and retry logic
            echo "üèóÔ∏è  Starting robust frontend container build..."
            
            if docker buildx build \
              --cache-from type=gha,scope=frontend \
              --cache-to type=gha,scope=frontend,mode=max \
              --platform linux/amd64 \
              --build-arg BUILDKIT_INLINE_CACHE=1 \
              --label "version=$IMAGE_TAG" \
              --label "build-date=$(date -u '+%Y-%m-%dT%H:%M:%SZ')" \
              --label "commit=$GITHUB_SHA" \
              --label "ci-system=github-actions" \
              --label "build-type=production" \
              -t $ECR_REGISTRY/$ECR_REPOSITORY_FRONTEND:$IMAGE_TAG \
              -t $ECR_REGISTRY/$ECR_REPOSITORY_FRONTEND:latest \
              --push .; then
              echo "‚úÖ Frontend container built and pushed successfully"
              echo "üìä Container details: $ECR_REGISTRY/$ECR_REPOSITORY_FRONTEND:$IMAGE_TAG"
              return 0
            else
              echo "‚ùå Frontend container build failed"
              echo "üîç Build failure troubleshooting:"
              echo "   ‚Ä¢ Check Dockerfile syntax and dependencies"
              echo "   ‚Ä¢ Verify package.json and package-lock.json are synchronized"
              echo "   ‚Ä¢ Check ECR repository permissions and network connectivity"
              echo "   ‚Ä¢ Review Docker build logs above for specific errors"
              return 1
            fi
          else
            echo "‚è≠Ô∏è  Frontend unchanged, skipping container build"
            return 0
          fi
        }
        
        # Execute builds in parallel background jobs
        echo "üîÑ Starting parallel build execution..."
        build_backend &
        BACKEND_PID=$!
        
        build_frontend &
        FRONTEND_PID=$!
        
        # Wait for both builds to complete
        echo "‚è≥ Waiting for parallel builds to complete..."
        
        BACKEND_EXIT=0
        FRONTEND_EXIT=0
        
        # Wait for backend build
        if wait $BACKEND_PID; then
          echo "‚úÖ Backend build completed successfully"
        else
          BACKEND_EXIT=$?
          echo "‚ùå Backend build failed with exit code $BACKEND_EXIT"
        fi
        
        # Wait for frontend build
        if wait $FRONTEND_PID; then
          echo "‚úÖ Frontend build completed successfully"
        else
          FRONTEND_EXIT=$?
          echo "‚ùå Frontend build failed with exit code $FRONTEND_EXIT"
        fi
        
        # Check overall success
        if [ $BACKEND_EXIT -eq 0 ] && [ $FRONTEND_EXIT -eq 0 ]; then
          echo "üéâ All parallel builds completed successfully!"
          echo "‚ö° Build time saved through parallelization"
        else
          echo "üí• Parallel build failed - Backend: $BACKEND_EXIT, Frontend: $FRONTEND_EXIT"
          exit 1
        fi

    - name: üèóÔ∏è  Prepare production environment
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ${{ secrets.EC2_USER }}
        key: ${{ secrets.EC2_SSH_KEY }}
        command_timeout: 5m
        script: |
          # =======================================================================
          # PRODUCTION ENVIRONMENT PREPARATION
          # =======================================================================
          
          echo "üöÄ Initializing production environment preparation..."
          
          # Create production directory structure with proper permissions
          echo "üìÅ Setting up production directory structure..."
          sudo mkdir -p /opt/websites/{nginx,scripts,apps/ical-viewer,backups,logs}
          sudo chown -R ec2-user:ec2-user /opt/websites
          echo "   ‚úÖ Directory structure created"
          
          # Clean up legacy deployment directories (graceful migration)
          echo "üßπ Cleaning up legacy deployment directories..."
          for legacy_dir in "/opt/ical-viewer" "/opt/multi-apps"; do
            if [ -d "$legacy_dir" ]; then
              echo "   üîÑ Stopping services in $legacy_dir"
              (cd "$legacy_dir" && docker-compose down 2>/dev/null) || true
            fi
          done
          echo "   ‚úÖ Legacy cleanup completed"
          
          # Initialize production directory
          cd /opt/websites
          echo "üìã Current directory: $(pwd)"
          
          # Create production environment configuration
          echo "‚öôÔ∏è  Creating production environment configuration..."
          cat > .env << 'EOF'
          # Production Environment Configuration
          AWS_ACCOUNT_ID=310829530903
          AWS_REGION=eu-north-1
          COMPOSE_PROJECT_NAME=websites
          DOCKER_BUILDKIT=1
          EOF
          echo "   ‚úÖ Environment configuration created"
          
          # Authenticate with ECR
          echo "üîê Authenticating with Amazon ECR..."
          if aws ecr get-login-password --region eu-north-1 | docker login --username AWS --password-stdin 310829530903.dkr.ecr.eu-north-1.amazonaws.com; then
            echo "   ‚úÖ ECR authentication successful"
          else
            echo "   ‚ùå ECR authentication failed"
            exit 1
          fi
          
          # =============================================================================
          # CREATE BACKUP OF CURRENT DEPLOYMENT (For Rollback Safety)
          # =============================================================================
          echo "üíæ Creating backup of current deployment for rollback safety..."
          
          # Check if containers are currently running
          if docker-compose ps | grep -q "Up"; then
            echo "üì¶ Current deployment detected - creating backup snapshots..."
            
            # Create backup tags for current images
            BACKEND_CURRENT=$(docker-compose images ical-viewer | tail -n 1 | awk '{print $4":"$5}' 2>/dev/null || echo "")
            FRONTEND_CURRENT=$(docker-compose images ical-viewer-frontend | tail -n 1 | awk '{print $4":"$5}' 2>/dev/null || echo "")
            
            if [ -n "$BACKEND_CURRENT" ] && [ "$BACKEND_CURRENT" != ":" ]; then
              docker tag "$BACKEND_CURRENT" "${BACKEND_CURRENT%:*}:backup-ical-viewer" 2>/dev/null || true
              echo "   ‚úÖ Backend backup created: backup-ical-viewer"
            fi
            
            if [ -n "$FRONTEND_CURRENT" ] && [ "$FRONTEND_CURRENT" != ":" ]; then
              docker tag "$FRONTEND_CURRENT" "${FRONTEND_CURRENT%:*}:backup-ical-viewer-frontend" 2>/dev/null || true
              echo "   ‚úÖ Frontend backup created: backup-ical-viewer-frontend"
            fi
          else
            echo "   ‚ÑπÔ∏è  No current deployment running - no backup needed"
          fi
          
          # Pre-pull latest container images
          echo "üì• Pre-pulling latest container images..."
          
          echo "   üì¶ Pulling backend image..."
          if docker pull 310829530903.dkr.ecr.eu-north-1.amazonaws.com/ical-viewer-backend:latest; then
            echo "   ‚úÖ Backend image pulled successfully"
          else
            echo "   ‚ùå Backend image pull failed"
            exit 1
          fi
          
          echo "   üé® Pulling frontend image..."
          if docker pull 310829530903.dkr.ecr.eu-north-1.amazonaws.com/ical-viewer-frontend:latest; then
            echo "   ‚úÖ Frontend image pulled successfully"
          else
            echo "   ‚ùå Frontend image pull failed"
            exit 1
          fi
          
          echo "‚úÖ Production environment preparation completed successfully"
    
    - name: üì§ Deploy configuration files to production
      uses: appleboy/scp-action@v0.1.7
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ${{ secrets.EC2_USER }}
        key: ${{ secrets.EC2_SSH_KEY }}
        source: "infrastructure/production-nginx.conf,infrastructure/production-docker-compose.yml"
        target: "/opt/websites/"
        strip_components: 1
        timeout: 30s
        use_insecure_cipher: false
    
    - name: Deploy Production Website Infrastructure
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ${{ secrets.EC2_USER }}
        key: ${{ secrets.EC2_SSH_KEY }}
        script: |
          cd /opt/websites
          
          # =============================================================================
          # PRODUCTION DEPLOYMENT ORCHESTRATION
          # =============================================================================
          
          echo "üöÄ Starting production deployment orchestration..."
          
          # Prepare configuration files with validation
          echo "üìã Preparing configuration files..."
          
          if [ -f "production-docker-compose.yml" ]; then
            mv production-docker-compose.yml docker-compose.yml
            echo "   ‚úÖ Docker Compose configuration updated"
          else
            echo "   ‚ö†Ô∏è  No new Docker Compose config found, using existing"
          fi
          
          if [ -f "production-nginx.conf" ]; then
            mkdir -p nginx
            mv production-nginx.conf nginx/nginx.conf
            echo "   ‚úÖ Nginx configuration updated"
          else
            echo "   ‚ö†Ô∏è  No new Nginx config found, using existing"
          fi
          
          # Validate docker-compose configuration
          echo "üîç Validating Docker Compose configuration..."
          if docker-compose config -q; then
            echo "   ‚úÖ Docker Compose configuration is valid"
          else
            echo "   ‚ùå Docker Compose configuration is invalid!"
            exit 1
          fi
          
          # Smart container update strategy
          CONTAINERS_TO_UPDATE=""
          BACKEND_CHANGED="${{ steps.changes.outputs.backend_changed }}"
          FRONTEND_CHANGED="${{ steps.changes.outputs.frontend_changed }}"
          
          echo "üì¶ Determining container update strategy..."
          
          if [[ "$BACKEND_CHANGED" == "true" ]]; then
            CONTAINERS_TO_UPDATE="$CONTAINERS_TO_UPDATE ical-viewer"
            echo "   üì± Backend changes detected - ical-viewer container will be updated"
          fi
          
          if [[ "$FRONTEND_CHANGED" == "true" ]]; then
            CONTAINERS_TO_UPDATE="$CONTAINERS_TO_UPDATE ical-viewer-frontend"
            echo "   üé® Frontend changes detected - ical-viewer-frontend container will be updated"
          fi
          
          # Execute deployment strategy with smart optimizations
          if [[ -z "$CONTAINERS_TO_UPDATE" ]]; then
            echo "‚ú® No application containers require updating - deployment complete"
            echo "üîç Current container status:"
            docker-compose ps
            
            # Skip full validation for no-change deployments (performance optimization)
            echo "‚ö° Skipping extensive validation (no changes deployed)"
            VALIDATION_FAILED=0
          else
            echo "üîÑ Executing optimized rolling update for containers:$CONTAINERS_TO_UPDATE"
            
            # Pull latest images in parallel for speed
            echo "üì• Pulling latest container images (parallel)..."
            (
              for container in $CONTAINERS_TO_UPDATE; do
                docker-compose pull $container &
              done
              wait
            )
            
            # Perform rolling update (no downtime)
            echo "üîÑ Performing zero-downtime rolling update..."
            docker-compose up -d --no-deps$CONTAINERS_TO_UPDATE
            
            # Adaptive stabilization wait based on container type
            if [[ "$CONTAINERS_TO_UPDATE" == *"ical-viewer"* ]]; then
              echo "‚è≥ Allowing backend to stabilize (extended wait for Python app)..."
              sleep 45
            else
              echo "‚è≥ Allowing services to stabilize..."
              sleep 20
            fi
            
            # Display current status
            echo "üîç Post-deployment container status:"
            docker-compose ps
            
            # Enhanced container health validation
            echo "üè• Running enhanced container health checks..."
            UNHEALTHY_CONTAINERS=0
            
            for container in $CONTAINERS_TO_UPDATE; do
              if docker-compose ps $container | grep -q "Exit\|unhealthy\|Restarting"; then
                echo "   ‚ùå Container $container is unhealthy"
                UNHEALTHY_CONTAINERS=$((UNHEALTHY_CONTAINERS + 1))
                docker-compose logs --tail=20 $container
              else
                echo "   ‚úÖ Container $container is healthy"
              fi
            done
            
            if [ $UNHEALTHY_CONTAINERS -gt 0 ]; then
              echo "‚ùå $UNHEALTHY_CONTAINERS container(s) failed health checks!"
              exit 1
            fi
            
            # Smart nginx restart (only if frontend changed)
            if [[ "$CONTAINERS_TO_UPDATE" == *"frontend"* ]]; then
              echo "üîÑ Restarting nginx (frontend changed)..."
              docker-compose restart nginx
              sleep 5
            else
              echo "‚è≠Ô∏è  Nginx restart skipped (frontend unchanged)"
            fi
          fi
          
          # =============================================================================
          # COMPREHENSIVE DEPLOYMENT VALIDATION
          # =============================================================================
          # These health checks ensure the deployment is actually working before
          # declaring success. Any failure will abort the deployment.
          
          echo "üß™ Running comprehensive production validation..."
          
          # Smart wait for backend initialization with health checks
          echo "‚è≥ Waiting for backend initialization (Python FastAPI startup)..."
          
          # Wait up to 3 minutes for backend to be fully ready
          MAX_WAIT=180
          WAIT_COUNT=0
          
          while [ $WAIT_COUNT -lt $MAX_WAIT ]; do
            if curl -f --connect-timeout 5 --max-time 10 http://localhost:3000/health > /dev/null 2>&1; then
              echo "   ‚úÖ Backend is ready after ${WAIT_COUNT}s"
              break
            fi
            
            if [ $((WAIT_COUNT % 15)) -eq 0 ]; then
              echo "   ‚è≥ Still waiting for backend (${WAIT_COUNT}s elapsed)..."
            fi
            
            sleep 5
            WAIT_COUNT=$((WAIT_COUNT + 5))
          done
          
          if [ $WAIT_COUNT -ge $MAX_WAIT ]; then
            echo "   ‚ö†Ô∏è  Backend took longer than expected to start, proceeding with validation"
          fi
          
          # Initialize validation tracking
          VALIDATION_FAILED=0
          
          # Test 1: HTTPS Site Response
          echo "üåê Test 1/6: HTTPS site accessibility..."
          if curl -f --connect-timeout 10 --max-time 30 https://filter-ical.de/ > /dev/null 2>&1; then
            echo "   ‚úÖ HTTPS site responding correctly"
          else
            echo "   ‚ùå HTTPS site not responding"
            VALIDATION_FAILED=1
          fi
          
          # Test 2: Dynamic Frontend Asset Detection (Framework Agnostic)
          echo "üìÑ Test 2/6: Frontend asset delivery (framework agnostic)..."
          
          # Modern approach: Check if the main page loads and contains asset references
          PAGE_ASSETS=$(echo "$PAGE_CONTENT" | grep -o 'src="[^"]*\.js"' | wc -l 2>/dev/null || echo "0")
          CSS_ASSETS=$(echo "$PAGE_CONTENT" | grep -o 'href="[^"]*\.css"' | wc -l 2>/dev/null || echo "0") 
          
          if [ "$PAGE_ASSETS" -gt 0 ] && [ "$CSS_ASSETS" -gt 0 ]; then
            echo "   ‚úÖ Frontend assets detected (JS: $PAGE_ASSETS, CSS: $CSS_ASSETS)"
          else
            echo "   ‚ùå Frontend assets not found in page content"
            echo "   üîç Page may not be loading correctly or assets missing"
            VALIDATION_FAILED=1
          fi
          
          # Test 3: Backend Health Endpoint
          echo "üîß Test 3/6: Backend health endpoint..."
          if curl -f --connect-timeout 10 --max-time 30 https://filter-ical.de/health > /dev/null 2>&1; then
            echo "   ‚úÖ Backend health check passed"
          else
            echo "   ‚ùå Backend health check failed"
            VALIDATION_FAILED=1
          fi
          
          # Test 4: Full Page Content Validation
          echo "üìä Test 4/6: Full page content integrity..."
          PAGE_CONTENT=$(curl -s --connect-timeout 10 --max-time 30 https://filter-ical.de/ 2>/dev/null || echo "")
          PAGE_SIZE=${#PAGE_CONTENT}
          
          if [ "$PAGE_SIZE" -gt 1000 ]; then
            echo "   ‚úÖ Page content complete ($PAGE_SIZE bytes)"
          else
            echo "   ‚ùå Page content incomplete or missing (only $PAGE_SIZE bytes)"
            VALIDATION_FAILED=1
          fi
          
          # Validate critical resources are accessible (catches deployment issues)
          echo "üîç Test 4.1/6: Checking frontend assets accessibility..."
          
          # Check for Vite-generated assets in /assets/ directory (modern SPA build)
          if curl -f --connect-timeout 5 --max-time 15 "https://filter-ical.de/assets/" > /dev/null 2>&1; then
            echo "   ‚úÖ /assets/ directory accessible"
          else
            echo "   ‚ùå /assets/ directory not accessible - frontend may not be deployed"
            VALIDATION_FAILED=1
          fi
          
          # Check backend API endpoint
          if curl -f --connect-timeout 5 --max-time 15 "https://filter-ical.de/api/calendars" > /dev/null 2>&1; then
            echo "   ‚úÖ /api/calendars accessible"
          else
            echo "   ‚ùå /api/calendars not accessible - backend may not be deployed"
            VALIDATION_FAILED=1
          fi
          
          # Test 5: Application Initialization Check
          echo "‚ö° Test 5/6: Application initialization..."
          if echo "$PAGE_CONTENT" | grep -q "iCal.*Viewer\|login\|calendar" 2>/dev/null; then
            echo "   ‚úÖ Application appears to be initializing correctly"
          else
            echo "   ‚ùå Application may not be initializing properly"
            VALIDATION_FAILED=1
          fi
          
          # Test 6: SSL Certificate Validation
          echo "üîí Test 6/6: SSL certificate validation..."
          if curl -s --connect-timeout 10 --max-time 30 -I https://filter-ical.de/ | grep -q "HTTP/[12].[01] 200" 2>/dev/null; then
            echo "   ‚úÖ SSL certificate and HTTPS working correctly"
          else
            echo "   ‚ùå SSL/HTTPS configuration issue detected"
            VALIDATION_FAILED=1
          fi
          
          # Final validation result
          echo ""
          if [ "$VALIDATION_FAILED" -eq 0 ]; then
            echo "‚úÖ ALL VALIDATION TESTS PASSED - Deployment successful!"
            echo "üåê Your website is fully operational at: https://filter-ical.de"
            
            # Clean up backup containers since deployment succeeded
            if docker images | grep -q "backup-"; then
              echo "üßπ Cleaning up backup containers after successful deployment..."
              docker images --format "table {{.Repository}}:{{.Tag}}" | grep "backup-" | xargs -r docker rmi 2>/dev/null || true
            fi
          else
            echo "‚ùå DEPLOYMENT VALIDATION FAILED - Initiating automatic rollback"
            echo "üîç Check the test results above to identify the issue"
            
            # =============================================================================
            # AUTOMATIC ROLLBACK MECHANISM
            # =============================================================================
            echo "üîÑ Starting automatic rollback to previous working version..."
            
            # Check if backup containers exist
            if docker images | grep -q "backup-"; then
              echo "üì¶ Found backup containers, rolling back..."
              
              # Stop current failed containers
              docker-compose stop ical-viewer ical-viewer-frontend 2>/dev/null || true
              
              # Tag backup images back to latest
              for container in ical-viewer ical-viewer-frontend; do
                BACKUP_IMAGE=$(docker images --format "table {{.Repository}}:{{.Tag}}" | grep "backup-$container" | head -1 | awk '{print $1}')
                if [ -n "$BACKUP_IMAGE" ]; then
                  ECR_REPO=$(echo $BACKUP_IMAGE | cut -d: -f1)
                  echo "   üîÑ Restoring $container from backup..."
                  docker tag "$BACKUP_IMAGE" "$ECR_REPO:latest"
                fi
              done
              
              # Restart with backup images
              docker-compose up -d ical-viewer ical-viewer-frontend
              
              # Wait for rollback to stabilize
              echo "‚è≥ Waiting for rollback to stabilize..."
              sleep 15
              
              # Quick validation of rollback
              if curl -f --connect-timeout 10 --max-time 20 https://filter-ical.de/health > /dev/null 2>&1; then
                echo "‚úÖ AUTOMATIC ROLLBACK SUCCESSFUL"
                echo "üåê Previous version restored at: https://filter-ical.de"
                echo "‚ö†Ô∏è  Please fix the issues above before attempting deployment again"
              else
                echo "‚ùå ROLLBACK FAILED - Manual intervention required"
                echo "üÜò Both current and previous versions are non-functional"
              fi
              
              # Clean up failed deployment images
              docker images --format "table {{.Repository}}:{{.Tag}}" | grep ":latest" | grep -E "(ical-viewer-backend|ical-viewer-frontend)" | xargs -r docker rmi --force 2>/dev/null || true
              
            else
              echo "‚ö†Ô∏è  No backup containers found - cannot rollback automatically"
              echo "üí° The deployment failed but no previous version backup exists"
            fi
            
            exit 1
          fi
          
          # Clean up old images to save space
          docker image prune -af --filter "until=24h"
          
          echo "‚úÖ Production deployment completed!"
          echo "üåê Your website is live at: https://filter-ical.de"
    
    # ===========================================================================
    # DEPLOYMENT COMPLETION NOTIFICATION
    # ===========================================================================
    # Provides clear feedback on deployment status with actionable information
    
    - name: üì¢ Notify deployment status
      if: always()
      run: |
        echo "================================================================================="
        echo "üèÅ DEPLOYMENT PIPELINE COMPLETED"
        echo "================================================================================="
        
        if [ "${{ job.status }}" == "success" ]; then
          # Calculate deployment performance metrics
          DEPLOY_END_TIME=$(date +%s)
          TOTAL_DEPLOY_TIME=$((DEPLOY_END_TIME - DEPLOY_START_TIME))
          DEPLOY_MINUTES=$((TOTAL_DEPLOY_TIME / 60))
          DEPLOY_SECONDS=$((TOTAL_DEPLOY_TIME % 60))
          
          echo "‚úÖ STATUS: SUCCESSFUL"
          echo "üåê LIVE SITE: https://${{ env.DOMAIN_NAME }}/"
          echo "‚è±Ô∏è  DEPLOYMENT TIME: ${DEPLOY_MINUTES}m ${DEPLOY_SECONDS}s"
          echo "üèóÔ∏è  ARCHITECTURE: Multi-container Docker with nginx reverse proxy"
          echo "üîí SECURITY: Let's Encrypt SSL with comprehensive security headers"
          echo "‚ö° FEATURES: Zero-downtime rolling updates with health validation"
          echo "üîÑ ROLLBACK: Automatic rollback on deployment failure"
          
          # Performance optimization suggestions
          if [ $TOTAL_DEPLOY_TIME -gt 300 ]; then
            echo "üí° PERFORMANCE: Deployment took over 5 minutes - consider optimizing Docker cache"
          elif [ $TOTAL_DEPLOY_TIME -lt 180 ]; then
            echo "üöÄ PERFORMANCE: Excellent deployment speed (under 3 minutes)"
          fi
          echo ""
          echo "üéØ Next steps:"
          echo "   ‚Ä¢ Test the live application functionality"
          echo "   ‚Ä¢ Monitor application logs if needed"
          echo "   ‚Ä¢ Check SSL certificate status"
        else
          echo "‚ùå STATUS: FAILED"
          echo "üîç TROUBLESHOOTING:"
          echo "   ‚Ä¢ Check the workflow logs above for specific error details"
          echo "   ‚Ä¢ Verify AWS credentials and permissions"
          echo "   ‚Ä¢ Ensure EC2 instance is accessible and healthy"
          echo "   ‚Ä¢ Check Docker container status on production server"
          echo "üÜò IMPACT: Automatic rollback initiated to maintain service availability"
          exit 1
        fi
        
        echo "================================================================================="