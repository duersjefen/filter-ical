# =============================================================================
# Industry Standard Three-Tier Environment CI/CD Pipeline
# =============================================================================
#
# Development ‚Üí Staging ‚Üí Production
# 
# This implements the industry best practice of:
# 1. Fast feedback loop for development
# 2. Production-identical staging environment
# 3. Controlled production deployments with approval gates
#
# Environment Strategy:
# - development: Auto-deploy from any branch (fast feedback)
# - staging: Auto-deploy from main/master (integration testing)  
# - production: Manual approval required (safety gate)
#
# =============================================================================

name: Multi-Environment Deployment Pipeline

on:
  push:
    branches: [main, master, develop, feature/**]
  pull_request:
    branches: [main, master]
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

# Global environment variables (shared across all environments)
env:
  AWS_REGION: eu-north-1
  ECR_REGISTRY: 310829530903.dkr.ecr.eu-north-1.amazonaws.com

jobs:
  # =============================================================================
  # UNIT & CONTRACT TESTS (Always run first)
  # =============================================================================
  test:
    name: üß™ Unit & Contract Tests
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    steps:
    - uses: actions/checkout@v4
    
    - name: üîß Build Test Container
      run: |
        cd backend
        docker build -t test-backend --target test .
    
    - name: üß™ Run Unit Tests
      run: |
        cd backend
        docker run --rm \
          -e ENV=test \
          -e DATABASE_URL=sqlite:///test.db \
          test-backend python3 -m pytest tests/ -m unit -v --tb=short
    
    - name: üìã Run Contract Tests
      run: |
        cd backend
        docker run --rm \
          -e ENV=test \
          -e DATABASE_URL=sqlite:///test.db \
          test-backend python3 -m pytest tests/test_contracts.py -v --tb=short

  # =============================================================================
  # DEVELOPMENT ENVIRONMENT (Any branch)
  # =============================================================================
  deploy-development:
    name: üöß Deploy to Development
    needs: test
    runs-on: ubuntu-latest
    environment: development
    timeout-minutes: 10
    
    # Deploy development for any branch (fast feedback)
    if: github.event_name == 'push'
    
    steps:
    - uses: actions/checkout@v4
    
    - name: üîê Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: arn:aws:iam::310829530903:role/GitHubActionsRole
        role-session-name: GitHubActionsSession-Dev
        aws-region: ${{ env.AWS_REGION }}
    
    - name: üîë Login to Amazon ECR
      uses: aws-actions/amazon-ecr-login@v2
    
    - name: üèóÔ∏è Setup Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: üèóÔ∏è Build and Push Branch Preview Images
      env:
        BRANCH_NAME: ${{ github.ref_name }}
        SAFE_BRANCH_NAME: ${{ github.ref_name }}
        IMAGE_TAG: dev-${{ github.sha }}
      run: |
        # Create safe branch name for container naming (replace / and special chars)
        SAFE_BRANCH_NAME=$(echo "$BRANCH_NAME" | sed 's/[^a-zA-Z0-9]/-/g' | tr '[:upper:]' '[:lower:]')
        echo "üöß Building branch preview: $BRANCH_NAME ‚Üí $SAFE_BRANCH_NAME"
        echo "üìç Preview URL will be: https://$SAFE_BRANCH_NAME.dev.filter-ical.de"
        
        # Build applications first
        make ci-build
        
        # Build and push development containers
        docker build -t "$ECR_REGISTRY/filter-ical-backend:$IMAGE_TAG" \
          --cache-from "$ECR_REGISTRY/filter-ical-backend:dev-latest" \
          --build-arg BUILDKIT_INLINE_CACHE=1 backend/
        docker tag "$ECR_REGISTRY/filter-ical-backend:$IMAGE_TAG" "$ECR_REGISTRY/filter-ical-backend:dev-latest"
        
        docker build -t "$ECR_REGISTRY/filter-ical-frontend:$IMAGE_TAG" \
          --cache-from "$ECR_REGISTRY/filter-ical-frontend:dev-latest" \
          --build-arg BUILDKIT_INLINE_CACHE=1 frontend/
        docker tag "$ECR_REGISTRY/filter-ical-frontend:$IMAGE_TAG" "$ECR_REGISTRY/filter-ical-frontend:dev-latest"
        
        # Push to ECR
        docker push "$ECR_REGISTRY/filter-ical-backend:$IMAGE_TAG" &
        docker push "$ECR_REGISTRY/filter-ical-backend:dev-latest" &
        docker push "$ECR_REGISTRY/filter-ical-frontend:$IMAGE_TAG" &
        docker push "$ECR_REGISTRY/filter-ical-frontend:dev-latest" &
        wait
        
    - name: üìÅ Sync Infrastructure to Development Server
      uses: appleboy/scp-action@v0.1.7
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ${{ secrets.EC2_USER }}
        key: ${{ secrets.EC2_SSH_KEY }}
        source: '.infra/docker/docker-compose.production.yml,.infra/docker/nginx.conf'
        target: '/opt/websites/'
        strip_components: 2
        
    - name: üöÄ Deploy Branch Preview to Development Server
      uses: ./.github/actions/execute-remote-docker
      with:
        containers: 'filter-ical-backend-dev filter-ical-frontend-dev'
        operation: 'deploy'
        nginx_restart: 'true'
        nginx_container: 'nginx'
      env:
        EC2_HOST: ${{ secrets.EC2_HOST }}
        EC2_USER: ${{ secrets.EC2_USER }}
        EC2_SSH_KEY: ${{ secrets.EC2_SSH_KEY }}
        ECR_REGISTRY: ${{ env.ECR_REGISTRY }}
        IMAGE_TAG: dev-${{ github.sha }}
        BRANCH_NAME: ${{ github.ref_name }}
        AWS_ACCOUNT_ID: "310829530903"
        AWS_REGION: ${{ env.AWS_REGION }}
        
    - name: üß™ Validate Branch Preview Deployment
      env:
        BRANCH_NAME: ${{ github.ref_name }}
        SAFE_BRANCH_NAME: ${{ github.ref_name }}
      run: |
        SAFE_BRANCH_NAME=$(echo "$BRANCH_NAME" | sed 's/[^a-zA-Z0-9]/-/g' | tr '[:upper:]' '[:lower:]')
        PREVIEW_URL="https://$SAFE_BRANCH_NAME.dev.filter-ical.de"
        echo "üéØ Branch Preview Ready!"
        echo "üìç Preview URL: $PREVIEW_URL"
        echo "üåø Branch: $BRANCH_NAME"
        echo "üí° Share this URL to demo your feature!"

  # =============================================================================
  # STAGING ENVIRONMENT (main/master only)
  # =============================================================================
  deploy-staging:
    name: üé≠ Deploy to Staging
    needs: test
    runs-on: ubuntu-latest
    environment: staging
    timeout-minutes: 15
    
    # Only deploy staging from main/master
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    
    steps:
    - uses: actions/checkout@v4
    
    - name: üîê Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: arn:aws:iam::310829530903:role/GitHubActionsRole
        role-session-name: GitHubActionsSession-Staging
        aws-region: ${{ env.AWS_REGION }}
    
    - name: üîë Login to Amazon ECR
      uses: aws-actions/amazon-ecr-login@v2
    
    - name: üèóÔ∏è Setup Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: üèóÔ∏è Build and Push Staging Images
      env:
        IMAGE_TAG: staging-${{ github.sha }}
      run: |
        echo "üé≠ Building staging containers with tag: $IMAGE_TAG"
        
        # Build applications first
        make ci-build
        
        # Build and push staging containers
        docker build -t "$ECR_REGISTRY/filter-ical-backend:$IMAGE_TAG" \
          --cache-from "$ECR_REGISTRY/filter-ical-backend:staging-latest" \
          --build-arg BUILDKIT_INLINE_CACHE=1 backend/
        docker tag "$ECR_REGISTRY/filter-ical-backend:$IMAGE_TAG" "$ECR_REGISTRY/filter-ical-backend:staging-latest"
        
        docker build -t "$ECR_REGISTRY/filter-ical-frontend:$IMAGE_TAG" \
          --cache-from "$ECR_REGISTRY/filter-ical-frontend:staging-latest" \
          --build-arg BUILDKIT_INLINE_CACHE=1 frontend/
        docker tag "$ECR_REGISTRY/filter-ical-frontend:$IMAGE_TAG" "$ECR_REGISTRY/filter-ical-frontend:staging-latest"
        
        # Push to ECR
        docker push "$ECR_REGISTRY/filter-ical-backend:$IMAGE_TAG" &
        docker push "$ECR_REGISTRY/filter-ical-backend:staging-latest" &
        docker push "$ECR_REGISTRY/filter-ical-frontend:$IMAGE_TAG" &
        docker push "$ECR_REGISTRY/filter-ical-frontend:staging-latest" &
        wait
    
    - name: üìÅ Sync Infrastructure to Staging Server
      uses: appleboy/scp-action@v0.1.7
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ${{ secrets.EC2_USER }}
        key: ${{ secrets.EC2_SSH_KEY }}
        source: '.infra/docker/docker-compose.production.yml,.infra/docker/nginx.conf'
        target: '/opt/websites/'
        strip_components: 2
    
    - name: üîç Validate Infrastructure Sync
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ${{ secrets.EC2_USER }}
        key: ${{ secrets.EC2_SSH_KEY }}
        envs: ECR_REGISTRY,AWS_ACCOUNT_ID,AWS_REGION
        script: |
          cd /opt/websites || { echo "‚ùå Failed to access /opt/websites"; exit 1; }
          
          echo "üîç Validating infrastructure files after sync..."
          
          # Check critical files exist with proper permissions
          if [[ ! -f "docker-compose.production.yml" ]]; then
            echo "‚ùå CRITICAL: docker-compose.production.yml not found after sync!"
            ls -la
            exit 1
          fi
          
          if [[ ! -f "nginx.conf" ]]; then
            echo "‚ùå CRITICAL: nginx.conf not found after sync!"
            ls -la  
            exit 1
          fi
          
          echo "‚úÖ Infrastructure files present"
          
          # Validate docker-compose file with environment variables
          export AWS_ACCOUNT_ID="${AWS_ACCOUNT_ID:-310829530903}"
          export AWS_REGION="${AWS_REGION:-eu-north-1}"
          export ECR_REGISTRY="${ECR_REGISTRY}"
          
          # Create working docker-compose.yml from production file
          cp docker-compose.production.yml docker-compose.yml
          
          # Test docker-compose configuration parsing
          if ! docker-compose config >/dev/null 2>&1; then
            echo "‚ùå CRITICAL: docker-compose.yml configuration invalid after sync!"
            echo "üîç Environment variables:"
            echo "   AWS_ACCOUNT_ID: $AWS_ACCOUNT_ID"
            echo "   AWS_REGION: $AWS_REGION"  
            echo "   ECR_REGISTRY: $ECR_REGISTRY"
            echo "üîç Config validation errors:"
            docker-compose config
            exit 1
          fi
          
          echo "‚úÖ docker-compose configuration valid"
          
          # Validate expected staging services are defined
          echo "üîç Validating staging services..."
          services=$(docker-compose config --services)
          
          expected_services="filter-ical-backend-staging filter-ical-frontend-staging"
          missing_services=""
          
          for service in $expected_services; do
            if echo "$services" | grep -q "^${service}$"; then
              echo "   ‚úÖ $service defined in compose file"
            else
              missing_services="$missing_services $service"
              echo "   ‚ùå $service missing from compose file"
            fi
          done
          
          if [ -n "$missing_services" ]; then
            echo "‚ùå CRITICAL: Missing staging services:$missing_services"
            echo "üîç Available services:"
            echo "$services" | sed 's/^/   /'
            exit 1
          fi
          
          echo "‚úÖ All staging services validated"
          echo "üéØ Infrastructure sync validation completed successfully"
        
    - name: üöÄ Deploy to Staging Server
      uses: ./.github/actions/execute-remote-docker
      with:
        containers: 'filter-ical-backend-staging filter-ical-frontend-staging'
        operation: 'deploy'
        nginx_restart: 'true'
        nginx_container: 'nginx'
      env:
        EC2_HOST: ${{ secrets.EC2_HOST }}
        EC2_USER: ${{ secrets.EC2_USER }}
        EC2_SSH_KEY: ${{ secrets.EC2_SSH_KEY }}
        ECR_REGISTRY: ${{ env.ECR_REGISTRY }}
        IMAGE_TAG: staging-${{ github.sha }}
        AWS_ACCOUNT_ID: "310829530903"
        AWS_REGION: ${{ env.AWS_REGION }}
    
    - name: üß™ Validate Staging Deployment
      uses: ./.github/actions/validate-endpoints
      with:
        domain: ${{ vars.DOMAIN_NAME_VAR }}  # TODO: Create separate staging domain
        endpoints: '/,/health,/domains/exter/groups'
        timeout: '30'
        retries: '5'

  # =============================================================================
  # PRODUCTION ENVIRONMENT (Manual approval required)
  # =============================================================================
  deploy-production:
    name: üåü Deploy to Production
    needs: deploy-staging
    runs-on: ubuntu-latest
    environment: production
    timeout-minutes: 20
    
    # Only deploy production from main/master after staging succeeds
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    
    steps:
    - uses: actions/checkout@v4
    
    - name: ‚è∞ Production Deployment Wait
      run: |
        echo "üåü Production deployment starting..."
        echo "‚è∞ This deployment was approved after the mandatory wait period"
        echo "üìã Staging validation passed successfully"
    
    - name: üîê Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: arn:aws:iam::310829530903:role/GitHubActionsRole
        role-session-name: GitHubActionsSession-Production
        aws-region: ${{ env.AWS_REGION }}
    
    - name: üîë Login to Amazon ECR
      uses: aws-actions/amazon-ecr-login@v2
    
    - name: üèóÔ∏è Setup Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: üèóÔ∏è Promote Staging Images to Production
      env:
        STAGING_TAG: staging-${{ github.sha }}
        PRODUCTION_TAG: ${{ github.sha }}
      run: |
        echo "üåü Promoting staging images to production"
        echo "üìã Source: $STAGING_TAG ‚Üí Target: $PRODUCTION_TAG"
        
        # Pull staging images
        docker pull "$ECR_REGISTRY/filter-ical-backend:$STAGING_TAG"
        docker pull "$ECR_REGISTRY/filter-ical-frontend:$STAGING_TAG"
        
        # Tag for production
        docker tag "$ECR_REGISTRY/filter-ical-backend:$STAGING_TAG" "$ECR_REGISTRY/filter-ical-backend:$PRODUCTION_TAG"
        docker tag "$ECR_REGISTRY/filter-ical-backend:$STAGING_TAG" "$ECR_REGISTRY/filter-ical-backend:latest"
        docker tag "$ECR_REGISTRY/filter-ical-frontend:$STAGING_TAG" "$ECR_REGISTRY/filter-ical-frontend:$PRODUCTION_TAG"
        docker tag "$ECR_REGISTRY/filter-ical-frontend:$STAGING_TAG" "$ECR_REGISTRY/filter-ical-frontend:latest"
        
        # Push production images
        docker push "$ECR_REGISTRY/filter-ical-backend:$PRODUCTION_TAG" &
        docker push "$ECR_REGISTRY/filter-ical-backend:latest" &
        docker push "$ECR_REGISTRY/filter-ical-frontend:$PRODUCTION_TAG" &
        docker push "$ECR_REGISTRY/filter-ical-frontend:latest" &
        wait
    
    - name: üìÅ Sync Infrastructure to Production Server
      uses: appleboy/scp-action@v0.1.7
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ${{ secrets.EC2_USER }}
        key: ${{ secrets.EC2_SSH_KEY }}
        source: '.infra/docker/docker-compose.production.yml,.infra/docker/nginx.conf'
        target: '/opt/websites/'
        strip_components: 2
    
    - name: üîç Validate Infrastructure Sync
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ${{ secrets.EC2_USER }}
        key: ${{ secrets.EC2_SSH_KEY }}
        envs: ECR_REGISTRY,AWS_ACCOUNT_ID,AWS_REGION
        script: |
          cd /opt/websites || { echo "‚ùå Failed to access /opt/websites"; exit 1; }
          
          echo "üîç Validating infrastructure files after sync..."
          
          # Check critical files exist with proper permissions
          if [[ ! -f "docker-compose.production.yml" ]]; then
            echo "‚ùå CRITICAL: docker-compose.production.yml not found after sync!"
            ls -la
            exit 1
          fi
          
          if [[ ! -f "nginx.conf" ]]; then
            echo "‚ùå CRITICAL: nginx.conf not found after sync!"
            ls -la  
            exit 1
          fi
          
          echo "‚úÖ Infrastructure files present"
          
          # Validate docker-compose file with environment variables
          export AWS_ACCOUNT_ID="${AWS_ACCOUNT_ID:-310829530903}"
          export AWS_REGION="${AWS_REGION:-eu-north-1}"
          export ECR_REGISTRY="${ECR_REGISTRY}"
          
          # Create working docker-compose.yml from production file
          cp docker-compose.production.yml docker-compose.yml
          
          # Test docker-compose configuration parsing
          if ! docker-compose config >/dev/null 2>&1; then
            echo "‚ùå CRITICAL: docker-compose.yml configuration invalid after sync!"
            echo "üîç Environment variables:"
            echo "   AWS_ACCOUNT_ID: $AWS_ACCOUNT_ID"
            echo "   AWS_REGION: $AWS_REGION"  
            echo "   ECR_REGISTRY: $ECR_REGISTRY"
            echo "üîç Config validation errors:"
            docker-compose config
            exit 1
          fi
          
          echo "‚úÖ docker-compose configuration valid"
          
          # Validate expected production services are defined
          echo "üîç Validating production services..."
          services=$(docker-compose config --services)
          
          expected_services="filter-ical filter-ical-frontend"
          missing_services=""
          
          for service in $expected_services; do
            if echo "$services" | grep -q "^${service}$"; then
              echo "   ‚úÖ $service defined in compose file"
            else
              missing_services="$missing_services $service"
              echo "   ‚ùå $service missing from compose file"
            fi
          done
          
          if [ -n "$missing_services" ]; then
            echo "‚ùå CRITICAL: Missing production services:$missing_services"
            echo "üîç Available services:"
            echo "$services" | sed 's/^/   /'
            exit 1
          fi
          
          echo "‚úÖ All production services validated"
          echo "üéØ Infrastructure sync validation completed successfully"
        
    - name: üöÄ Deploy to Production Server
      uses: ./.github/actions/execute-remote-docker
      with:
        containers: 'filter-ical filter-ical-frontend'
        operation: 'deploy'
        nginx_restart: 'true'
        nginx_container: 'nginx'
      env:
        EC2_HOST: ${{ secrets.EC2_HOST }}
        EC2_USER: ${{ secrets.EC2_USER }}
        EC2_SSH_KEY: ${{ secrets.EC2_SSH_KEY }}
        ECR_REGISTRY: ${{ env.ECR_REGISTRY }}
        IMAGE_TAG: ${{ github.sha }}
        AWS_ACCOUNT_ID: "310829530903"
        AWS_REGION: ${{ env.AWS_REGION }}
    
    - name: üß™ Validate Production Deployment
      uses: ./.github/actions/validate-endpoints
      with:
        domain: ${{ vars.DOMAIN_NAME_VAR }}
        endpoints: '/,/health,/domains/exter/groups'
        timeout: '60'
        retries: '10'
    
    - name: üìä Production Deployment Summary
      run: |
        echo "=================================================================================="
        echo "üåü PRODUCTION DEPLOYMENT COMPLETED SUCCESSFULLY"
        echo "=================================================================================="
        echo "üìä Environment: Production"
        echo "üöÄ Domain: ${{ vars.DOMAIN_NAME_VAR }}"
        echo "üè∑Ô∏è Version: ${{ github.sha }}"
        echo "üë§ Approved by: ${{ github.actor }}"
        echo "‚è∞ Deployed at: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
        echo ""
        echo "‚úÖ Three-tier deployment pipeline completed:"
        echo "   1. ‚úÖ Unit & Contract Tests passed"
        echo "   2. ‚úÖ Staging deployment verified"
        echo "   3. ‚úÖ Production deployment approved and deployed"
        echo "   4. ‚úÖ Production validation successful"
        echo "=================================================================================="

  # =============================================================================
  # AUTOMATIC ROLLBACK (Production only)
  # =============================================================================
  rollback-production:
    name: üîÑ Emergency Production Rollback
    needs: deploy-production
    runs-on: ubuntu-latest
    environment: production
    if: failure() && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')
    
    steps:
    - uses: actions/checkout@v4
    
    - name: üîÑ Execute Emergency Rollback
      uses: ./.github/actions/rollback-deployment
      with:
        containers: 'filter-ical filter-ical-frontend'
        domain: ${{ vars.DOMAIN_NAME_VAR }}
        nginx_restart: 'true'
        nginx_container: 'nginx'
        validation_endpoints: '/,/health'
      env:
        EC2_HOST: ${{ secrets.EC2_HOST }}
        EC2_USER: ${{ secrets.EC2_USER }}
        EC2_SSH_KEY: ${{ secrets.EC2_SSH_KEY }}
        ECR_REGISTRY: ${{ env.ECR_REGISTRY }}